<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Dice Game</title>
    <!-- Favicon - D20 Die -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><polygon points='50,5 95,30 95,70 50,95 5,70 5,30' fill='%231a1a2e' stroke='%23ffd700' stroke-width='3'/><polygon points='50,5 95,30 50,50' fill='%234a4a6a'/><polygon points='5,30 50,5 50,50' fill='%233a3a5a'/><polygon points='50,50 95,30 95,70 50,95' fill='%232a2a4a'/><polygon points='50,50 5,30 5,70 50,95' fill='%23353555'/><text x='50' y='58' text-anchor='middle' fill='%23ffd700' font-family='Arial' font-size='24' font-weight='bold'>20</text></svg>">
    <!-- Google Fonts for player distinction -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Rajdhani:wght@700&family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Action Type Colors */
            --physical-primary: #c45c26;
            --physical-secondary: #8b4513;
            --physical-glow: rgba(196, 92, 38, 0.6);

            --verbal-primary: #2980b9;
            --verbal-secondary: #1a5276;
            --verbal-glow: rgba(41, 128, 185, 0.6);

            --preventative-primary: #8e44ad;
            --preventative-secondary: #5b2c6f;
            --preventative-glow: rgba(142, 68, 173, 0.6);

            /* DOOM/HOPE Colors */
            --doom-color: #8b0000;
            --hope-color: #4ade80;

            /* Player Fonts */
            --font-player1: 'Cinzel', serif;
            --font-player2: 'Rajdhani', sans-serif;
            --font-player3: 'Permanent Marker', cursive;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #eee;
            overflow-x: hidden;
        }

        /* Screen Transitions */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
            z-index: 100;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        /* ==================== TITLE SCREEN ==================== */
        .title-screen {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
            z-index: 1000;
        }

        .title-logo {
            text-align: center;
            margin-bottom: 60px;
        }

        .title-dice {
            font-size: 80px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .title-logo h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 0.1em;
            margin-top: 20px;
        }

        .title-logo .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-top: 10px;
            font-style: italic;
        }

        .title-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px;
        }

        .menu-btn {
            padding: 18px 30px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 2px solid #4a4a6a;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .menu-btn:hover {
            background: linear-gradient(135deg, #3a3a5a, #2a2a4a);
            border-color: #ffd700;
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.2);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            border-color: #ffd700;
        }

        .menu-btn.primary:hover {
            background: linear-gradient(135deg, #ffee00, #ffcc00);
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4);
        }

        .version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #555;
            font-size: 0.9rem;
        }

        /* ==================== HOW TO PLAY SCREEN ==================== */
        .howto-screen {
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            overflow-y: auto;
        }

        .howto-content {
            max-width: 800px;
            text-align: left;
        }

        .howto-content h1 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-align: center;
        }

        .howto-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid #ffd700;
        }

        .howto-section h2 {
            color: #88ccff;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .howto-section p {
            line-height: 1.8;
            color: #ccc;
        }

        .dice-type-preview {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .type-preview {
            text-align: center;
            padding: 15px 25px;
            border-radius: 10px;
        }

        .type-preview.physical { background: var(--physical-secondary); }
        .type-preview.verbal { background: var(--verbal-secondary); }
        .type-preview.preventative { background: var(--preventative-secondary); }

        .type-preview h4 { margin-bottom: 8px; }
        .type-preview ul { list-style: none; text-align: left; }

        .back-btn {
            margin-top: 30px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        }

        /* ==================== SETUP SCREEN ==================== */
        .setup-screen {
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            overflow-y: auto;
        }

        .setup-screen h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .setup-screen .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .setup-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            max-width: 900px;
            width: 100%;
        }

        .player-setup {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 4px solid #555;
        }

        .player-setup.player-1 { border-left-color: #ffd700; }
        .player-setup.player-2 { border-left-color: #88ccff; }
        .player-setup.player-3 { border-left-color: #ff88cc; }

        .player-setup h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-setup.player-1 h3 { font-family: var(--font-player1); }
        .player-setup.player-2 h3 { font-family: var(--font-player2); }
        .player-setup.player-3 h3 { font-family: var(--font-player3); }

        .player-name-input {
            padding: 8px 12px;
            border: 2px solid #4a4a6a;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border-radius: 5px;
            font-size: 1rem;
            width: 150px;
        }

        .player-setup.player-1 .player-name-input { font-family: var(--font-player1); }
        .player-setup.player-2 .player-name-input { font-family: var(--font-player2); }
        .player-setup.player-3 .player-name-input { font-family: var(--font-player3); }

        .dice-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .dice-category {
            flex: 1;
            min-width: 150px;
        }

        .dice-category h4 {
            margin-bottom: 10px;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }

        .dice-category h4.physical { background: var(--physical-secondary); }
        .dice-category h4.verbal { background: var(--verbal-secondary); }
        .dice-category h4.preventative { background: var(--preventative-secondary); }

        .dice-option {
            display: block;
            padding: 10px 15px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .dice-option input {
            margin-right: 10px;
        }

        .dice-option.physical { background: rgba(196, 92, 38, 0.2); }
        .dice-option.verbal { background: rgba(41, 128, 185, 0.2); }
        .dice-option.preventative { background: rgba(142, 68, 173, 0.2); }

        .dice-option:hover {
            transform: translateX(5px);
        }

        .dice-option.physical:hover { border-color: var(--physical-primary); }
        .dice-option.verbal:hover { border-color: var(--verbal-primary); }
        .dice-option.preventative:hover { border-color: var(--preventative-primary); }

        .start-btn {
            display: block;
            width: 100%;
            padding: 20px;
            font-size: 1.3rem;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .start-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
        }

        /* ==================== TALENT RANKING ==================== */
        .talent-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
        }

        .talent-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px 35px;
            background: rgba(30, 30, 40, 0.8);
            border: 2px solid #444;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        .talent-btn .die-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .talent-btn .die-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .talent-btn .category-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .talent-btn.physical { border-color: var(--physical-primary); }
        .talent-btn.verbal { border-color: var(--verbal-primary); }
        .talent-btn.preventative { border-color: var(--preventative-primary); }

        .talent-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .talent-btn.physical:hover { box-shadow: 0 10px 30px rgba(196, 92, 38, 0.4); }
        .talent-btn.verbal:hover { box-shadow: 0 10px 30px rgba(41, 128, 185, 0.4); }
        .talent-btn.preventative:hover { box-shadow: 0 10px 30px rgba(142, 68, 173, 0.4); }

        .talent-btn.selected {
            transform: translateY(-5px);
            border-width: 3px;
        }

        .talent-btn.physical.selected { background: rgba(196, 92, 38, 0.3); }
        .talent-btn.verbal.selected { background: rgba(41, 128, 185, 0.3); }
        .talent-btn.preventative.selected { background: rgba(142, 68, 173, 0.3); }

        .talent-hint {
            text-align: center;
            color: #4ade80;
            font-size: 1.1rem;
            margin-top: 20px;
        }

        /* Intertwine Screen */
        .intertwine-step {
            margin: 25px 0;
            padding: 20px;
            background: rgba(30, 30, 40, 0.5);
            border-radius: 10px;
        }

        .intertwine-step h3 {
            color: #c084fc;
            margin-bottom: 15px;
        }

        .intertwine-step.hidden {
            display: none;
        }

        .number-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .number-btn {
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            font-weight: bold;
            background: rgba(50, 50, 60, 0.8);
            border: 2px solid #666;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .number-btn:hover {
            border-color: #c084fc;
            transform: scale(1.1);
        }

        .number-btn.selected {
            background: rgba(192, 132, 252, 0.3);
            border-color: #c084fc;
            box-shadow: 0 0 20px rgba(192, 132, 252, 0.4);
        }

        .ally-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
        }

        .ally-btn {
            padding: 15px 30px;
            font-size: 1.1rem;
            background: rgba(50, 50, 60, 0.8);
            border: 2px solid #666;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .ally-btn.player-1 { border-color: #ff6b6b; }
        .ally-btn.player-2 { border-color: #4ecdc4; }
        .ally-btn.player-3 { border-color: #ffe66d; }

        .ally-btn:hover {
            transform: scale(1.05);
        }

        .ally-btn.selected {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .ally-dice-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .confirm-btn {
            display: block;
            margin: 20px auto 0;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .confirm-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.5);
        }

        /* Intertwine Progress */
        .intertwine-progress {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(30, 30, 40, 0.6);
            border-radius: 10px;
        }

        .intertwine-progress span {
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 0.95rem;
        }

        .intertwine-progress span.active {
            background: rgba(192, 132, 252, 0.3);
            border: 2px solid #c084fc;
            color: #c084fc;
            font-weight: bold;
        }

        .intertwine-progress span.done {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid #4ade80;
            color: #4ade80;
        }

        .intertwine-progress .arrow {
            color: #666;
            font-size: 1.2rem;
        }

        .number-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        .number-btn.disabled:hover {
            transform: none;
            border-color: #666;
        }

        /* ==================== MAIN GAME ==================== */
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .game-screen {
            z-index: 50;
        }

        .game-screen.hidden {
            display: none;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4a4a6a;
        }

        .header h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            color: #ffd700;
        }

        .floor-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .gold {
            color: #ffd700;
            font-weight: bold;
        }

        /* DOOM/HOPE Display */
        .doom-hope-display {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .doom-meter, .hope-meter {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .doom-meter {
            background: rgba(139, 0, 0, 0.3);
            border: 2px solid var(--doom-color);
            color: #ff6b6b;
        }

        .hope-meter {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid var(--hope-color);
            color: var(--hope-color);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4a4a6a;
            color: #aaa;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        /* Main game area */
        .main-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Map Panel */
        .map-panel {
            width: 280px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 2px solid #4a4a6a;
            padding: 15px;
            overflow-y: auto;
        }

        .map-panel h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #88ccff;
            font-family: 'Cinzel', serif;
        }

        .map-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .map-row {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .map-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid #444;
        }

        .map-node.current {
            border-color: #ffd700;
            box-shadow: 0 0 20px #ffd700;
            animation: pulse 1.5s infinite;
        }

        .map-node.completed {
            opacity: 0.4;
            border-color: #333;
        }

        .map-node.locked {
            opacity: 0.25;
            cursor: not-allowed;
        }

        .map-node.available {
            border-color: #88ff88;
            cursor: pointer;
        }

        .map-node.available:hover {
            transform: scale(1.15);
            box-shadow: 0 0 15px #88ff88;
        }

        .map-node.good { background: linear-gradient(135deg, #2d5a27, #1d4a17); }
        .map-node.bad { background: linear-gradient(135deg, #5a2727, #4a1717); }
        .map-node.neutral { background: linear-gradient(135deg, #5a5a27, #4a4a17); }
        .map-node.boss { background: linear-gradient(135deg, #5a2757, #4a1747); }
        .map-node.start { background: linear-gradient(135deg, #275a5a, #174a4a); }

        .map-path {
            width: 3px;
            height: 15px;
            background: linear-gradient(to bottom, #555, #333);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px #ffd700; }
            50% { box-shadow: 0 0 30px #ffd700; }
        }

        /* Encounter Panel */
        .encounter-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .encounter-content {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .encounter-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .encounter-header h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .encounter-type {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .encounter-type.good { background: #2d5a27; }
        .encounter-type.bad { background: #5a2727; }
        .encounter-type.neutral { background: #5a5a27; }
        .encounter-type.boss { background: #5a2757; }

        .encounter-description {
            flex: 1;
            padding: 15px;
            line-height: 1.7;
            font-size: 1.05rem;
        }

        .encounter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
        }

        .option-btn {
            padding: 15px 25px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            background: #3a3a5a;
            color: #fff;
        }

        .option-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .option-btn.physical {
            background: var(--physical-secondary);
            border-color: var(--physical-primary);
        }
        .option-btn.physical:hover { box-shadow: 0 8px 25px var(--physical-glow); }

        .option-btn.verbal {
            background: var(--verbal-secondary);
            border-color: var(--verbal-primary);
        }
        .option-btn.verbal:hover { box-shadow: 0 8px 25px var(--verbal-glow); }

        .option-btn.preventative {
            background: var(--preventative-secondary);
            border-color: var(--preventative-primary);
        }
        .option-btn.preventative:hover { box-shadow: 0 8px 25px var(--preventative-glow); }

        .option-btn.swap {
            background: linear-gradient(135deg, #4a3a6a, #3a2a5a);
            border-color: #8855cc;
        }
        .option-btn.swap:hover { box-shadow: 0 8px 25px rgba(136, 85, 204, 0.5); }

        .option-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Players sidebar */
        .players-panel {
            width: 220px;
            background: rgba(0, 0, 0, 0.4);
            border-right: 2px solid #4a4a6a;
            padding: 15px;
            overflow-y: auto;
        }

        .players-panel > h3 {
            font-family: 'Cinzel', serif;
            margin-bottom: 15px;
            color: #88ccff;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            border-left: 4px solid #555;
        }

        .player-card.player-1 { border-left-color: #ffd700; }
        .player-card.player-2 { border-left-color: #88ccff; }
        .player-card.player-3 { border-left-color: #ff88cc; }

        .player-card h3 {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
        }

        .player-card.player-1 h3 { font-family: var(--font-player1); }
        .player-card.player-2 h3 { font-family: var(--font-player2); }
        .player-card.player-3 h3 { font-family: var(--font-player3); }

        .player-hp {
            font-family: 'Segoe UI', system-ui, sans-serif !important;
        }

        .player-dice-mini {
            display: flex;
            gap: 5px;
        }

        .mini-die {
            width: 35px;
            height: 35px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            text-align: center;
            font-weight: bold;
            position: relative;
        }

        .mini-die.physical { background: var(--physical-secondary); }
        .mini-die.verbal { background: var(--verbal-secondary); }
        .mini-die.preventative { background: var(--preventative-secondary); }

        .mini-die .swap-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            background: #8855cc;
            border-radius: 50%;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ==================== DICE TRAY ==================== */
        .dice-tray {
            background: linear-gradient(to bottom, #252535, #151525);
            border-top: 3px solid #4a4a6a;
            padding: 15px 20px;
            min-height: 160px;
        }

        .dice-tray-header {
            text-align: center;
            margin-bottom: 12px;
            color: #88ccff;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
        }

        .dice-grid {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .player-dice-group {
            text-align: center;
        }

        .player-dice-group h4 {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #888;
        }

        .player-dice-group.player-1 h4 {
            font-family: var(--font-player1);
            color: #ffd700;
        }
        .player-dice-group.player-2 h4 {
            font-family: var(--font-player2);
            color: #88ccff;
        }
        .player-dice-group.player-3 h4 {
            font-family: var(--font-player3);
            color: #ff88cc;
        }

        .dice-row {
            display: flex;
            gap: 10px;
        }

        .die {
            width: 75px;
            height: 75px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            position: relative;
        }

        /* Physical dice */
        .die.physical {
            background: linear-gradient(145deg, var(--physical-primary), var(--physical-secondary));
            border-color: var(--physical-primary);
        }
        .die.physical:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--physical-glow);
        }

        /* Verbal dice */
        .die.verbal {
            background: linear-gradient(145deg, var(--verbal-primary), var(--verbal-secondary));
            border-color: var(--verbal-primary);
        }
        .die.verbal:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--verbal-glow);
        }

        /* Preventative dice */
        .die.preventative {
            background: linear-gradient(145deg, var(--preventative-primary), var(--preventative-secondary));
            border-color: var(--preventative-primary);
        }
        .die.preventative:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--preventative-glow);
        }

        .die:hover:not(.disabled) {
            transform: translateY(-8px) scale(1.05);
        }

        .die.selected {
            border-color: #ffd700 !important;
            box-shadow: 0 0 25px #ffd700 !important;
        }

        .die.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        .die.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .die.already-rolled {
            opacity: 0.5;
            filter: grayscale(30%);
            border-color: #4ade80 !important;
            position: relative;
        }

        .die.already-rolled::after {
            content: 'âœ“';
            position: absolute;
            top: -10px;
            right: -10px;
            background: #4ade80;
            color: #000;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .die.has-swap {
            border-style: dashed;
        }

        .die .swap-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #8855cc;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Player-specific fonts on dice */
        .die.player-1 .die-name { font-family: var(--font-player1); }
        .die.player-2 .die-name { font-family: var(--font-player2); }
        .die.player-3 .die-name { font-family: var(--font-player3); }

        .die-name {
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .die-value {
            font-size: 1.6rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .die.rolling {
            animation: diceRoll 0.15s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.05); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.05); }
            100% { transform: rotate(0deg) scale(1); }
        }

        /* ==================== MODALS ==================== */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Roll Result */
        .roll-result {
            text-align: center;
        }

        .roll-result-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid #ffd700;
        }

        .roll-result h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: #aaa;
        }

        .roll-result .result-value {
            font-size: 6rem;
            font-weight: bold;
            margin: 20px 0;
            font-family: 'Cinzel', serif;
        }

        .roll-result .result-value.success { color: #4ade80; }
        .roll-result .result-value.fail { color: #f87171; }
        .roll-result .result-value.crit {
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            animation: critGlow 0.5s infinite alternate;
        }

        .roll-result .swap-triggered {
            background: rgba(136, 85, 204, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px 0;
            color: #cc99ff;
            font-style: italic;
        }

        @keyframes critGlow {
            from { text-shadow: 0 0 20px #ffd700; }
            to { text-shadow: 0 0 40px #ffd700, 0 0 60px #ffaa00; }
        }

        .roll-result .outcome {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: #ccc;
            white-space: pre-line;
        }

        /* DOOM Roll styling */
        .roll-result .outcome.doom-death {
            color: #ff3333;
            text-shadow: 0 0 20px #ff0000;
            animation: doomPulse 0.5s infinite alternate;
        }
        .roll-result .outcome.doom-saved {
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
        }
        .roll-result .outcome.doom-close {
            color: #ff8800;
        }
        .roll-result .outcome.doom-safe {
            color: #88ccff;
        }

        @keyframes doomPulse {
            from { text-shadow: 0 0 10px #ff0000; transform: scale(1); }
            to { text-shadow: 0 0 30px #ff0000, 0 0 50px #880000; transform: scale(1.02); }
        }

        .roll-result .doom-change {
            padding: 8px 16px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .roll-result .doom-change.doom-up {
            background: rgba(139, 0, 0, 0.3);
            color: #ff6b6b;
        }

        .roll-result .doom-change.doom-down {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .roll-result button {
            padding: 12px 40px;
            font-size: 1rem;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            background: #4a4a6a;
            border: 2px solid #6a6a8a;
            color: white;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .roll-result button:hover {
            background: #5a5a7a;
            transform: translateY(-2px);
        }

        /* Upgrade Modal */
        .upgrade-modal .modal-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 30px;
            border-radius: 15px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            border: 2px solid #4a4a6a;
        }

        .upgrade-modal h2 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .upgrade-modal p {
            color: #aaa;
            margin-bottom: 20px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .upgrade-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            border: 2px solid transparent;
        }

        .upgrade-option:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
            border-color: #ffd700;
        }

        .upgrade-option.swap-option {
            border-color: #8855cc;
            background: rgba(136, 85, 204, 0.15);
        }

        .upgrade-option.swap-option:hover {
            border-color: #aa77ee;
            background: rgba(136, 85, 204, 0.25);
        }

        .upgrade-option h4 {
            color: #88ccff;
            margin-bottom: 5px;
        }

        .upgrade-option p {
            color: #888;
            font-size: 0.9rem;
            margin: 0;
        }

        /* Pause Modal */
        .pause-modal .modal-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #4a4a6a;
            min-width: 300px;
        }

        .pause-modal h2 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Game Log */
        .game-log {
            position: fixed;
            bottom: 180px;
            left: 15px;
            width: 280px;
            max-height: 180px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.8rem;
            z-index: 100;
            border: 1px solid #333;
        }

        .game-log h4 {
            color: #666;
            margin-bottom: 8px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .log-entry {
            padding: 4px 8px;
            border-radius: 3px;
            margin-bottom: 3px;
            color: #999;
        }

        .log-entry.success { color: #4ade80; background: rgba(74, 222, 128, 0.1); }
        .log-entry.fail { color: #f87171; background: rgba(248, 113, 113, 0.1); }
        .log-entry.crit { color: #ffd700; background: rgba(255, 215, 0, 0.1); }
        .log-entry.info { color: #88ccff; background: rgba(136, 204, 255, 0.1); }
        .log-entry.doom { color: #ff6b6b; background: rgba(139, 0, 0, 0.2); }
        .log-entry.hope { color: #4ade80; background: rgba(74, 222, 128, 0.15); }
        .log-entry.swap { color: #cc99ff; background: rgba(136, 85, 204, 0.15); }

        /* ==================== END SCREENS ==================== */
        .end-screen {
            z-index: 3000;
        }

        .end-content {
            text-align: center;
        }

        .end-screen h1 {
            font-family: 'Cinzel', serif;
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .end-screen.victory h1 {
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }
        .end-screen.defeat h1 {
            color: #f87171;
        }

        .end-screen p {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #aaa;
        }

        .end-screen .end-buttons {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        /* Stage Shop Styles */
        .shop-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 30px;
            text-align: center;
        }

        .shop-container h1 {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .shop-points {
            font-size: 1.4em;
            color: #4ade80;
            margin: 20px 0;
        }

        .shop-points span {
            font-weight: bold;
            color: #ffd700;
        }

        .shop-players {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .shop-player-section {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #444;
        }

        .shop-player-section h3 {
            color: #4ade80;
            margin-bottom: 15px;
        }

        .shop-upgrades {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .shop-upgrade-btn {
            background: rgba(50,50,70,0.8);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 10px 15px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 140px;
        }

        .shop-upgrade-btn:hover:not(:disabled) {
            background: rgba(70,70,100,0.9);
            border-color: #ffd700;
        }

        .shop-upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-upgrade-btn.purchased {
            background: rgba(74,222,128,0.3);
            border-color: #4ade80;
        }

        .shop-upgrade-btn .cost {
            display: block;
            font-size: 0.8em;
            color: #ffd700;
            margin-top: 5px;
        }

        .shop-upgrade-btn .tier-locked {
            display: block;
            font-size: 0.7em;
            color: #f87171;
            margin-top: 3px;
        }

        .shop-footer {
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <!-- ==================== TITLE SCREEN ==================== -->
    <div class="screen title-screen" id="titleScreen">
        <div class="title-logo">
            <div class="title-dice">ðŸŽ²</div>
            <h1>UNTITLED DICE GAME</h1>
            <p class="subtitle">A Collaborative TTRPG Adventure</p>
        </div>
        <div class="title-menu">
            <button class="menu-btn primary" onclick="showScreen('setupScreen')">New Game</button>
            <button class="menu-btn" onclick="showScreen('howtoScreen')">How to Play</button>
            <button class="menu-btn" onclick="showScreen('settingsScreen')">Settings</button>
        </div>
        <div class="version">v0.2.0 - Dice Swapping Update</div>
    </div>

    <!-- ==================== HOW TO PLAY SCREEN ==================== -->
    <div class="screen howto-screen hidden" id="howtoScreen">
        <div class="howto-content">
            <h1>How to Play</h1>

            <div class="howto-section">
                <h2>Objective</h2>
                <p>Work together with your party of 3 heroes to defeat the Dirty Innkeeper! Navigate through encounters, upgrade your dice, and make strategic decisions to survive.</p>
            </div>

            <div class="howto-section">
                <h2>Your Dice</h2>
                <p>Each player has 3 dice - one from each action category. Click a die in the tray to roll it during encounters. Each die starts as a standard d20, but can be upgraded!</p>
                <div class="dice-type-preview">
                    <div class="type-preview physical">
                        <h4>Physical</h4>
                        <ul>
                            <li>Slash</li>
                            <li>Stab</li>
                            <li>Bonk</li>
                        </ul>
                    </div>
                    <div class="type-preview verbal">
                        <h4>Verbal</h4>
                        <ul>
                            <li>Threaten</li>
                            <li>Deceive</li>
                            <li>Persuade</li>
                        </ul>
                    </div>
                    <div class="type-preview preventative">
                        <h4>Preventative</h4>
                        <ul>
                            <li>Bribe</li>
                            <li>Hide</li>
                            <li>Grapple</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="howto-section">
                <h2>Dice Swapping</h2>
                <p>The unique mechanic! You can link segments of your dice to teammates' dice. When you roll a swapped number, your teammate's die activates instead - for better or worse!</p>
            </div>

            <div class="howto-section">
                <h2>DOOM & HOPE</h2>
                <p><strong>DOOM</strong> accumulates when you fail or get hit. High DOOM makes your dice weaker. Roll a Nat 1 with high DOOM and your journey ends!<br><br>
                <strong>HOPE</strong> offsets DOOM. Earn it through certain encounters and upgrades.</p>
            </div>

            <div class="howto-section">
                <h2>The Map</h2>
                <p>Navigate through branching paths. Green borders = available paths. Different icons show encounter types:</p>
                <ul style="margin-top:10px; margin-left:20px; line-height:2;">
                    <li><span style="color:#4ade80;">Good</span> - Safe encounters, upgrades, shops</li>
                    <li><span style="color:#f87171;">Bad</span> - Combat encounters, risk vs reward</li>
                    <li><span style="color:#ffd700;">Neutral</span> - Could go either way...</li>
                    <li><span style="color:#c084fc;">Boss</span> - The floor's final challenge</li>
                </ul>
            </div>

            <button class="menu-btn back-btn" onclick="showScreen('titleScreen')">Back to Menu</button>
        </div>
    </div>

    <!-- ==================== SETTINGS SCREEN ==================== -->
    <div class="screen howto-screen hidden" id="settingsScreen">
        <div class="howto-content" style="max-width:500px;">
            <h1>Settings</h1>

            <div class="howto-section">
                <h2>Sound</h2>
                <p style="color:#666;">(Coming soon - sound effects and music)</p>
            </div>

            <div class="howto-section">
                <h2>Save Data</h2>
                <p style="color:#666;">(Coming soon - save slots)</p>
            </div>

            <button class="menu-btn back-btn" onclick="showScreen('titleScreen')">Back to Menu</button>
        </div>
    </div>

    <!-- ==================== SETUP SCREEN ==================== -->
    <div class="screen setup-screen hidden" id="setupScreen">
        <h1>Party Setup</h1>
        <p class="subtitle">Floor 1: The Dirty Innkeeper</p>
        <div class="setup-content">
            <div class="player-setup player-1">
                <h3>
                    <span>Player 1:</span>
                    <input type="text" class="player-name-input" id="p1name" value="Hero" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="slash" checked> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="stab"> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="bonk"> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="threaten" checked> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="deceive"> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="persuade"> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="bribe" checked> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="hide"> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="grapple"> Grapple</label>
                    </div>
                </div>
            </div>

            <div class="player-setup player-2">
                <h3>
                    <span>Player 2:</span>
                    <input type="text" class="player-name-input" id="p2name" value="Rogue" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="slash"> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="stab" checked> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="bonk"> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="threaten"> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="deceive" checked> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="persuade"> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="bribe"> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="hide" checked> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="grapple"> Grapple</label>
                    </div>
                </div>
            </div>

            <div class="player-setup player-3">
                <h3>
                    <span>Player 3:</span>
                    <input type="text" class="player-name-input" id="p3name" value="Bard" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="slash"> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="stab"> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="bonk" checked> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="threaten"> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="deceive"> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="persuade" checked> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="bribe"> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="hide"> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="grapple" checked> Grapple</label>
                    </div>
                </div>
            </div>

            <button class="start-btn" onclick="startTalentRanking()">Begin Adventure</button>
        </div>
    </div>

    <!-- ==================== TALENT RANKING SCREEN ==================== -->
    <div class="screen setup-screen hidden" id="talentScreen">
        <h1 id="talentTitle">Talent Ranking</h1>
        <p class="subtitle" id="talentSubtitle">You've picked the 3 things your character is good at. But which are they BEST at?</p>
        <div class="setup-content" id="talentContent">
            <!-- Dynamically populated -->
        </div>
    </div>

    <!-- ==================== INTERTWINE SCREEN ==================== -->
    <div class="screen setup-screen hidden" id="intertwineScreen">
        <h1>Intertwine Your Fates</h1>
        <p class="subtitle" id="intertwineSubtitle"></p>
        <div class="setup-content" id="intertwineContent">
            <!-- Dynamically populated -->
        </div>
    </div>

    <!-- ==================== MAIN GAME ==================== -->
    <div class="game-screen hidden" id="gameScreen">
        <div class="game-container">
            <div class="header">
                <h1>UNTITLED DICE GAME</h1>
                <div class="floor-info">
                    <span>Floor 1: The Dirty Innkeeper</span>
                    <span class="gold" id="goldDisplay">0G</span>
                    <div class="doom-hope-display">
                        <div class="doom-meter"><span id="doomDisplay">0</span> DOOM</div>
                        <div class="hope-meter"><span id="hopeDisplay">0</span> HOPE</div>
                    </div>
                </div>
                <div class="header-buttons">
                    <button class="header-btn" onclick="showPauseMenu()">Menu</button>
                </div>
            </div>

            <div class="main-area">
                <div class="players-panel">
                    <h3>Party</h3>
                    <div id="playersDisplay"></div>
                </div>

                <div class="encounter-panel">
                    <div class="encounter-content" id="encounterContent">
                        <div class="encounter-header">
                            <h2 id="encounterTitle">The Rusty Tankard</h2>
                            <span class="encounter-type" id="encounterType" style="display:none;"></span>
                        </div>
                        <div class="encounter-description" id="encounterDescription">
                            <p>Your party arrives at The Rusty Tankard inn as dusk settles over the town. Rumors of the innkeeper's shady dealings have reached your ears...</p>
                            <p style="margin-top:15px;">Click the <strong>house icon</strong> on the map to enter and begin your adventure.</p>
                        </div>
                        <div class="encounter-options" id="encounterOptions"></div>
                    </div>
                </div>

                <div class="map-panel">
                    <h2>Map</h2>
                    <div class="map-container" id="mapContainer"></div>
                </div>
            </div>

            <div class="dice-tray">
                <div class="dice-tray-header">Dice Tray - Click to Roll</div>
                <div class="dice-grid" id="diceTray"></div>
            </div>
        </div>

        <div class="game-log" id="gameLog">
            <h4>Log</h4>
        </div>
    </div>

    <!-- ==================== MODALS ==================== -->

    <!-- Roll Result -->
    <div class="modal roll-result" id="rollResult">
        <div class="roll-result-content">
            <h2 id="rollDieName">Rolling...</h2>
            <div id="swapTriggered" class="swap-triggered" style="display:none;"></div>
            <div class="result-value" id="rollValue">?</div>
            <div id="doomChange" class="doom-change" style="display:none;"></div>
            <div class="outcome" id="rollOutcome"></div>
            <button onclick="closeRollResult()">Continue</button>
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div class="modal upgrade-modal" id="upgradeModal">
        <div class="modal-content">
            <h2 id="upgradeTitle">Choose an Upgrade</h2>
            <p id="upgradeDescription"></p>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>

    <!-- Pause Modal -->
    <div class="modal pause-modal" id="pauseModal">
        <div class="modal-content">
            <h2>Paused</h2>
            <div class="pause-menu">
                <button class="menu-btn" onclick="closePauseMenu()">Resume</button>
                <button class="menu-btn" onclick="restartGame()">Restart Floor</button>
                <button class="menu-btn" onclick="quitToMenu()">Quit to Menu</button>
            </div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div class="screen end-screen victory hidden" id="victoryScreen">
        <div class="end-content">
            <h1>VICTORY!</h1>
            <p id="victoryMessage">You have defeated the boss!</p>
            <p id="victoryNextStage" style="color:#ffd700;"></p>
            <div class="end-buttons">
                <button class="menu-btn primary" id="continueBtn" onclick="advanceToNextStage()" style="display:none;">Continue to Next Stage</button>
                <button class="menu-btn primary" id="finalVictoryBtn" onclick="location.reload()" style="display:none;">Play Again</button>
                <button class="menu-btn" onclick="quitToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Final Victory Screen -->
    <div class="screen end-screen victory hidden" id="finalVictoryScreen">
        <div class="end-content">
            <h1 style="color:#ffd700;">THE PROPHECY IS FULFILLED!</h1>
            <p>You have defeated B.O.M.B. and saved the world!</p>
            <p style="color:#4ade80;">The 20th prophecy was true. The heroes prevailed.</p>
            <div class="end-buttons">
                <button class="menu-btn primary" onclick="location.reload()">Play Again</button>
                <button class="menu-btn" onclick="quitToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Stage Shop Screen -->
    <div class="screen hidden" id="stageShopScreen">
        <div class="shop-container">
            <h1 id="shopStageTitle">Stage 2 Preparation</h1>
            <p id="shopDescription">Spend your Favor to prepare for the challenges ahead.</p>
            <p class="shop-points">Favor Remaining: <span id="shopPointsRemaining">0</span></p>

            <div class="shop-players" id="shopPlayers">
                <!-- Player shop sections will be generated here -->
            </div>

            <div class="shop-footer">
                <p style="color:#888; font-size:0.9em;">Upgrades purchased here reset after this stage. Only your initial talents are permanent.</p>
                <button class="menu-btn primary" onclick="confirmShopAndContinue()">Begin Stage</button>
            </div>
        </div>
    </div>

    <!-- Defeat Screen -->
    <div class="screen end-screen defeat hidden" id="defeatScreen">
        <div class="end-content">
            <h1>DEFEAT</h1>
            <p id="defeatReason">Your party has fallen...</p>
            <div class="end-buttons">
                <button class="menu-btn primary" onclick="location.reload()">Try Again</button>
                <button class="menu-btn" onclick="quitToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME STATE ====================
        const gameState = {
            gold: 0,
            doom: 0,
            hope: 0,
            currentNode: 0,
            currentStage: 1, // Stage 1-5, determines which boss to use
            players: [],
            map: [],
            currentEncounter: null,
            encounterState: null,
            targetDC: 10,
            canRoll: false,
            allowedDiceTypes: ['physical', 'verbal', 'preventative'],
            pendingSwapResult: null,
            // Voting system
            voting: {
                active: false,
                options: [],
                votes: {}, // playerIdx -> optionIdx
                round: 1,
                node: null
            },
            // Favor (points) system - resets each stage
            favor: 0,
            purchasedUpgrades: [] // Track what was bought this stage [{playerIdx, upgradeId}]
        };

        // ==================== DEFINITIONS ====================
        const DICE_TYPES = {
            slash: { name: 'Slash', category: 'physical', icon: 'SL' },
            stab: { name: 'Stab', category: 'physical', icon: 'ST' },
            bonk: { name: 'Bonk', category: 'physical', icon: 'BK' },
            threaten: { name: 'Threaten', category: 'verbal', icon: 'TH' },
            deceive: { name: 'Deceive', category: 'verbal', icon: 'DC' },
            persuade: { name: 'Persuade', category: 'verbal', icon: 'PR' },
            bribe: { name: 'Bribe', category: 'preventative', icon: 'BR' },
            hide: { name: 'Hide', category: 'preventative', icon: 'HD' },
            grapple: { name: 'Grapple', category: 'preventative', icon: 'GR' }
        };

        const ENCOUNTERS = {
            start: {
                type: 'start',
                name: 'The Rusty Tankard',
                description: 'You push open the creaky door and enter the dingy inn. The air smells of stale ale and something worse. Shadowy figures huddle in corners, and the innkeeper watches you with suspicious eyes.',
                icon: 'ðŸ ',
                options: [
                    { text: 'Look around and proceed', action: 'leave' }
                ]
            },
            mathematician: {
                type: 'good',
                name: 'The Mathematician',
                description: 'A strange old man with ink-stained fingers beckons you. "Numbers are my trade. Let me improve your odds... free of charge!"',
                icon: 'ðŸ”¢',
                options: [
                    { text: 'Free Lesson (+2 to lowest face)', action: 'math_free' },
                    { text: 'Trade-off (-1 from high, +4 to low)', action: 'math_tradeoff' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            alchemist: {
                type: 'good',
                name: 'The Alchemist',
                description: 'Bubbling potions fill the cramped shop. A wild-eyed woman grins at you. "I can splice your dice together! Link your fates... no charge for first-timers!"',
                icon: 'âš—ï¸',
                options: [
                    { text: 'Basic Splice (Link low roll to ally)', action: 'swap_low_to_ally' },
                    { text: 'Risky Splice (Random link + free +2)', action: 'alchemist_risky' },
                    { text: 'Double Link (Link to BOTH allies!)', action: 'alchemist_double' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            priest: {
                type: 'good',
                name: 'The Priest',
                description: 'A serene figure in white robes offers a blessing. "Let me infuse your dice with HOPE. The light will protect you in dark times."',
                icon: 'âœ¨',
                options: [
                    { text: 'Accept Blessing (+3 HOPE)', action: 'blessing_hope' },
                    { text: 'Mark a Die (+5 HOPE, mark one face)', action: 'blessing_greater' },
                    { text: 'Bless a Segment (+HOPE on a roll)', action: 'blessing_segment' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            gambler: {
                type: 'good',
                name: 'The Gambler',
                description: 'A shifty-eyed woman shuffles cards and spins a wheel. "Pick IN or OUT of the range, then roll! Either way, you win something!"',
                icon: 'ðŸŽ°',
                options: [
                    { text: 'Play the Range Game', action: 'gamble_range_choice' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            bandits: {
                type: 'bad',
                name: 'Bandit Ambush!',
                description: 'Three rough-looking thugs block your path! "Your gold or your lives!"',
                icon: 'âš”ï¸',
                dc: 12, reward: 30,
                successThresholds: { physical: 2, verbal: 2, preventative: 1 },
                options: [
                    { text: 'Engage!', action: 'combat' }
                ]
            },
            guards: {
                type: 'bad',
                name: 'Corrupt Guards',
                description: 'Two city guards eye you suspiciously. "Pay the \'peace tax\' or face justice."',
                icon: 'ðŸ›¡ï¸',
                dc: 13, reward: 25,
                successThresholds: { physical: 2, verbal: 1, preventative: 2 },
                options: [
                    { text: 'Engage!', action: 'combat' }
                ]
            },
            ferryman: {
                type: 'neutral',
                name: 'The Ferryman',
                description: 'An ancient boatman waits by dark waters. His eyes gleam with ancient wisdom. "The river knows your fate. Roll and let the waters judge you. Or... pay 5 gold for guaranteed safe passage."',
                icon: 'â›µ',
                vote: true,
                options: [
                    { text: 'Roll for Fate (Free)', action: 'ferryman_roll' },
                    { text: 'Pay 5G (Guaranteed good)', action: 'ferryman_paid', cost: 5 },
                    { text: 'Wade the shallows (+1 DOOM)', action: 'ferryman_wade' }
                ]
            },
            trapper: {
                type: 'neutral',
                name: 'The Trapper',
                description: 'A grizzled hunter displays three strange dice covered in odd symbols. "Trade one of yours for one of mine. The stronger your sacrifice, the better the die you get..."',
                icon: 'ðŸª¤',
                vote: true,
                options: [
                    { text: 'View the Exotic Dice', action: 'trapper_exotic' },
                    { text: 'Pay 8G (Pick any exotic die)', action: 'trapper_paid', cost: 8 },
                    { text: 'Leave empty-handed', action: 'leave' }
                ]
            },
            drunkPriest: {
                type: 'neutral',
                name: 'The Drunk Priest',
                description: 'A priest stumbles towards you, bottle in hand. "Blessings! ...hic... The gods speak through me. For 3 gold, I\'ll sober up just enough to do it right."',
                icon: 'ðŸº',
                vote: true,
                options: [
                    { text: 'Accept the Blessing (Free)', action: 'drunk_blessing' },
                    { text: 'Pay 3G (Guaranteed +3 HOPE)', action: 'drunk_paid', cost: 3 },
                    { text: 'Decline politely', action: 'leave' }
                ]
            },
            cultist: {
                type: 'neutral',
                name: 'The Cultist',
                description: 'A robed figure offers you a goblet of strange purple liquid. "The cup shows many visions. For 10 gold, I can add the sacred herb that ensures only good visions."',
                icon: 'ðŸ·',
                vote: true,
                options: [
                    { text: 'Drink from the Goblet (Free)', action: 'cultist_drink' },
                    { text: 'Pay 10G (Guaranteed swap + upgrade)', action: 'cultist_paid', cost: 10 },
                    { text: 'Politely decline', action: 'leave' }
                ]
            },
            miniboss: {
                type: 'bad',
                name: 'The Innkeeper\'s Thug',
                description: 'A massive bouncer blocks the stairs. "Boss don\'t want visitors." His fists look like hammers.',
                icon: 'ðŸ’ª',
                dc: 14, reward: 40,
                successThresholds: { physical: 3, verbal: 2, preventative: 2 },
                options: [
                    { text: 'Engage!', action: 'combat' }
                ]
            },
            boss: {
                type: 'boss',
                name: 'The Dirty Innkeeper',
                description: 'The innkeeper reveals his true nature - a cunning crime lord! "You\'ve meddled enough. Time to deal with you personally."',
                icon: 'ðŸ‘‘',
                dc: 10, reward: 100,
                successThresholds: { physical: 4, verbal: 3, preventative: 2 },
                attacksPerRound: 1,
                options: [
                    { text: 'Engage!', action: 'combat' }
                ]
            }
        };

        // Boss definitions for all 5 stages
        // Philosophy: Early = peace rewarded, Late = combat efficient against cosmic horror
        const BOSSES = {
            1: {
                name: 'The Dirty Innkeeper',
                description: 'The innkeeper reveals his true nature - a cunning crime lord!',
                dc: 10,
                successThresholds: { physical: 4, verbal: 3, preventative: 2 },
                attacksPerRound: 1
            },
            2: {
                name: 'The Corrupt Guard',
                description: 'The guard captain draws his blade, ATOM\'s sigil gleaming on his armor.',
                dc: 12,
                successThresholds: { physical: 5, verbal: 4, preventative: 3 },
                attacksPerRound: 1
            },
            3: {
                name: 'General Heimer',
                description: 'The General stands before his troops. "You will not pass. The King demands it."',
                dc: 14,
                successThresholds: { physical: 6, verbal: 6, preventative: 5 },
                attacksPerRound: 1
            },
            4: {
                name: 'Chthonic King Robert',
                description: 'The King rises from his throne, dark energy crackling around him. "ATOM\'s will is my will!"',
                dc: 15,
                successThresholds: { physical: 7, verbal: 7, preventative: 7 },
                attacksPerRound: 1
            },
            5: {
                name: 'B.O.M.B.',
                description: 'The Big Obvious Malicious Boss manifests. Reality bends. This is the final stand.',
                dc: 16,
                successThresholds: { physical: 8, verbal: 10, preventative: 9 },
                attacksPerRound: 2
            }
        };

        // Stage info for floor names and theming
        const STAGE_INFO = {
            1: { name: 'The Dirty Innkeeper', location: 'The Crossroads Inn' },
            2: { name: 'The Corrupt Guard', location: 'The Castle Gates' },
            3: { name: 'General Heimer', location: 'The Capitol Siege' },
            4: { name: 'King Robert', location: 'The Throne Room' },
            5: { name: 'B.O.M.B.', location: 'The Warped Dimension' }
        };

        // Favor points per stage - increases each stage to allow stronger builds
        const STAGE_FAVOR = {
            1: 0,  // Stage 1 has no shop (only talent ranking)
            2: 4,  // First shop experience
            3: 6,  // More options
            4: 8,  // Serious preparation
            5: 10  // Final stand
        };

        // Available upgrades - tier determines which stage unlocks them
        // No HP upgrades - game uses success thresholds, not health
        const SHOP_UPGRADES = [
            // Tier 1 - Available from Stage 2
            { id: 'die_plus2', name: '+2 to Lowest', description: 'Add 2 to lowest die face', cost: 1, tier: 1, effect: 'die_upgrade', value: 2 },
            { id: 'gold_bonus', name: '+25 Gold', description: 'Start with extra gold', cost: 1, tier: 1, effect: 'gold', value: 25 },
            { id: 'hope_small', name: '+1 HOPE', description: 'Start with HOPE', cost: 1, tier: 1, effect: 'hope', value: 1 },

            // Tier 2 - Available from Stage 3
            { id: 'die_plus5', name: '+5 to Lowest', description: 'Add 5 to lowest die face', cost: 2, tier: 2, effect: 'die_upgrade', value: 5 },
            { id: 'hope_start', name: '+2 HOPE', description: 'More starting HOPE', cost: 2, tier: 2, effect: 'hope', value: 2 },
            { id: 'doom_reduce', name: '-2 DOOM', description: 'Reduce starting DOOM', cost: 2, tier: 2, effect: 'doom_reduce', value: 2 },

            // Tier 3 - Available from Stage 4
            { id: 'die_upgrade_all', name: '+3 All Dice', description: 'Add 3 to all lowest faces', cost: 3, tier: 3, effect: 'die_upgrade_all', value: 3 },
            { id: 'hope_medium', name: '+3 HOPE', description: 'Significant HOPE boost', cost: 3, tier: 3, effect: 'hope', value: 3 },
            { id: 'gold_large', name: '+50 Gold', description: 'Major gold bonus', cost: 2, tier: 3, effect: 'gold', value: 50 },

            // Tier 4 - Available from Stage 5
            { id: 'die_supercharge', name: '+10 to Best', description: 'Supercharge your best die', cost: 4, tier: 4, effect: 'die_supercharge', value: 10 },
            { id: 'hope_surge', name: '+5 HOPE', description: 'Maximum HOPE boost', cost: 4, tier: 4, effect: 'hope', value: 5 },
            { id: 'doom_purge', name: '-5 DOOM', description: 'Major DOOM reduction', cost: 3, tier: 4, effect: 'doom_reduce', value: 5 }
        ];

        // Stage 5 warped encounters only - Stages 1-4 use common ENCOUNTERS
        const STAGE_5_ENCOUNTERS = {
            start: { type: 'good', name: 'The Rift', description: 'Reality tears apart. You fall through into... somewhere else.', icon: 'ðŸŒ€', options: [{ text: 'Continue', action: 'leave' }] },
            fragment: { type: 'good', name: 'Memory Fragment', description: 'A shard of your past floats before you. It pulses with warmth.', icon: 'ðŸ’Ž', options: [{ text: 'Touch it (restore die)', action: 'restore_die' }, { text: 'Leave', action: 'leave' }] },
            echo: { type: 'bad', name: 'Echo of BOMB', description: 'A shadow of the final boss. A taste of what\'s to come.', icon: 'ðŸ‘ï¸', dc: 15, reward: 40, successThresholds: { physical: 3, verbal: 3, preventative: 2 }, options: [{ text: 'Engage!', action: 'combat' }] },
            sanctuary: { type: 'good', name: 'Pocket of Reality', description: 'A small bubble of normal space. A moment to breathe.', icon: 'ðŸï¸', options: [{ text: 'Gather strength (+2 HOPE)', action: 'sanctuary_rest' }, { text: 'Continue', action: 'leave' }] },
            void: { type: 'bad', name: 'Void Creatures', description: 'Shapeless horrors from beyond reality attack!', icon: 'ðŸ‘¾', dc: 15, reward: 45, successThresholds: { physical: 3, verbal: 2, preventative: 3 }, options: [{ text: 'Engage!', action: 'combat' }] },
            prophecy: { type: 'neutral', name: 'The 19 Darkened Lines', description: 'You see the 19 failed prophecies. Only yours remains lit.', icon: 'ðŸ“–', options: [{ text: 'Accept your destiny (+HOPE)', action: 'accept_destiny' }, { text: 'Continue', action: 'leave' }] },
            miniboss: { type: 'bad', name: 'The Shard of BOMB', description: 'A fragment of the cosmic horror blocks your path. It\'s smaller, but no less deadly.', icon: 'ðŸ’€', dc: 15, reward: 50, successThresholds: { physical: 4, verbal: 4, preventative: 3 }, options: [{ text: 'Engage!', action: 'combat' }] },
            rift2: { type: 'good', name: 'Reality Tear', description: 'Another tear in reality. Warmth seeps through.', icon: 'âœ¨', options: [{ text: 'Touch it (+1 HOPE)', action: 'rift_touch' }, { text: 'Continue', action: 'leave' }] }
        };

        // ==================== SCREEN MANAGEMENT ====================
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
        }

        function showPauseMenu() {
            document.getElementById('pauseModal').classList.add('show');
        }

        function closePauseMenu() {
            document.getElementById('pauseModal').classList.remove('show');
        }

        function restartGame() {
            location.reload();
        }

        function quitToMenu() {
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('titleScreen').classList.remove('hidden');
        }

        function advanceToNextStage() {
            // Hide victory screen
            document.getElementById('victoryScreen').classList.add('hidden');

            // Advance stage
            gameState.currentStage++;

            // Reset temporary upgrades - restore dice to permanent state
            resetTemporaryUpgrades();

            // Reset DOOM for new stage
            gameState.doom = 0;

            // Show the shop for the new stage
            showStageShop();
        }

        function resetTemporaryUpgrades() {
            // Clear purchased upgrades list
            gameState.purchasedUpgrades = [];

            // Reset dice to their permanent (talent-ranked) state
            // The permanent upgrades are stored in each die's baseFaces
            gameState.players.forEach(player => {
                Object.values(player.dice).forEach(die => {
                    if (die.baseFaces) {
                        die.faces = [...die.baseFaces];
                    }
                });
            });
        }

        function showStageShop() {
            const stage = gameState.currentStage;
            const stageInfo = STAGE_INFO[stage];
            const favor = STAGE_FAVOR[stage];

            // Set up favor
            gameState.favor = favor;
            gameState.purchasedUpgrades = [];

            // Update shop UI
            document.getElementById('shopStageTitle').textContent = `Stage ${stage}: ${stageInfo.location}`;
            document.getElementById('shopDescription').textContent = stage === 5
                ? 'This is your final stand. Spend your Favor wisely.'
                : 'Spend your Favor to prepare for the challenges ahead.';
            document.getElementById('shopPointsRemaining').textContent = favor;

            // Generate player shop sections
            renderShopPlayers();

            // Show shop screen
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById('stageShopScreen').classList.remove('hidden');
        }

        function renderShopPlayers() {
            const stage = gameState.currentStage;
            const maxTier = stage - 1; // Stage 2 = Tier 1, Stage 3 = Tier 2, etc.

            const container = document.getElementById('shopPlayers');
            container.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                const section = document.createElement('div');
                section.className = 'shop-player-section';

                let upgradesHtml = '';
                SHOP_UPGRADES.forEach(upgrade => {
                    const purchased = gameState.purchasedUpgrades.some(
                        p => p.playerIdx === pIdx && p.upgradeId === upgrade.id
                    );
                    const canAfford = gameState.favor >= upgrade.cost;
                    const tierUnlocked = upgrade.tier <= maxTier;
                    const disabled = !tierUnlocked || !canAfford || purchased;

                    upgradesHtml += `
                        <button class="shop-upgrade-btn ${purchased ? 'purchased' : ''}"
                                onclick="purchaseUpgrade(${pIdx}, '${upgrade.id}')"
                                ${disabled ? 'disabled' : ''}>
                            ${upgrade.name}
                            <span class="cost">${upgrade.cost} Favor</span>
                            ${!tierUnlocked ? `<span class="tier-locked">Stage ${upgrade.tier + 1}+</span>` : ''}
                        </button>
                    `;
                });

                section.innerHTML = `
                    <h3>${player.name}</h3>
                    <div class="shop-upgrades">${upgradesHtml}</div>
                `;
                container.appendChild(section);
            });
        }

        function purchaseUpgrade(playerIdx, upgradeId) {
            const upgrade = SHOP_UPGRADES.find(u => u.id === upgradeId);
            if (!upgrade || gameState.favor < upgrade.cost) return;

            // Deduct favor
            gameState.favor -= upgrade.cost;

            // Track purchase
            gameState.purchasedUpgrades.push({ playerIdx, upgradeId });

            // Apply effect
            const player = gameState.players[playerIdx];
            switch (upgrade.effect) {
                case 'die_upgrade':
                    // Upgrade lowest face of a random die
                    const dieTypes = Object.keys(player.dice);
                    const randomDie = player.dice[dieTypes[Math.floor(Math.random() * dieTypes.length)]];
                    const minFace = Math.min(...randomDie.faces);
                    const minIdx = randomDie.faces.indexOf(minFace);
                    randomDie.faces[minIdx] += upgrade.value;
                    break;
                case 'die_upgrade_all':
                    Object.values(player.dice).forEach(die => {
                        const minFace = Math.min(...die.faces);
                        const minIdx = die.faces.indexOf(minFace);
                        die.faces[minIdx] += upgrade.value;
                    });
                    break;
                case 'die_supercharge':
                    // Upgrade best die's highest face
                    const bestDie = Object.values(player.dice).reduce((best, die) =>
                        Math.max(...die.faces) > Math.max(...best.faces) ? die : best
                    );
                    const maxFace = Math.max(...bestDie.faces);
                    const maxIdx = bestDie.faces.indexOf(maxFace);
                    bestDie.faces[maxIdx] += upgrade.value;
                    break;
                case 'gold':
                    gameState.gold += upgrade.value;
                    break;
                case 'hope':
                    gameState.hope += upgrade.value;
                    break;
                case 'doom_reduce':
                    gameState.doom = Math.max(0, gameState.doom - upgrade.value);
                    break;
            }

            // Update UI
            document.getElementById('shopPointsRemaining').textContent = gameState.favor;
            renderShopPlayers();
        }

        function confirmShopAndContinue() {
            // Hide shop
            document.getElementById('stageShopScreen').classList.add('hidden');

            // Update displays
            updateDoomHopeDisplay();

            // Generate new map for new stage
            generateMap();

            // Update floor display
            updateFloorDisplay();

            // Show game screen
            document.getElementById('gameScreen').classList.remove('hidden');

            // Render everything
            renderMap();
            renderPlayers();
            renderDiceTray();

            // Make first node available
            gameState.map[0].status = 'available';
            renderMap();

            // Log
            const stageInfo = STAGE_INFO[gameState.currentStage];
            document.getElementById('gameLog').innerHTML = '<h4>Log</h4>';
            log(`Stage ${gameState.currentStage}: ${stageInfo.name}`, 'info');
            log(`Welcome to ${stageInfo.location}...`, 'info');
        }

        function updateFloorDisplay() {
            const stage = gameState.currentStage;
            const stageInfo = STAGE_INFO[stage];
            const floorText = `Stage ${stage}: ${stageInfo.name}`;

            // Update header
            const floorSpan = document.querySelector('.floor-info span');
            if (floorSpan) {
                floorSpan.textContent = floorText;
            }
        }

        function showBossVictory() {
            const stage = gameState.currentStage;
            const bossName = BOSSES[stage].name;

            document.getElementById('victoryMessage').textContent = `You have defeated ${bossName}!`;

            if (stage >= 5) {
                // Final victory!
                document.getElementById('victoryScreen').classList.add('hidden');
                document.getElementById('finalVictoryScreen').classList.remove('hidden');
            } else {
                // More stages to go
                const nextStageInfo = STAGE_INFO[stage + 1];
                document.getElementById('victoryNextStage').textContent = `Stage ${stage + 1}: ${nextStageInfo.location} awaits...`;
                document.getElementById('continueBtn').style.display = 'block';
                document.getElementById('finalVictoryBtn').style.display = 'none';
                document.getElementById('victoryScreen').classList.remove('hidden');
            }
        }

        // ==================== TALENT RANKING SYSTEM ====================
        const talentState = {
            currentPlayer: 0,
            phase: 'best', // 'best', 'worst', 'intertwine'
            playerRankings: [] // [{best: 'physical', worst: 'verbal', middle: 'preventative'}, ...]
        };

        function startTalentRanking() {
            // First, create the players from the setup screen
            gameState.players = [];
            gameState.gold = 0;
            gameState.doom = 0;
            gameState.hope = 0;
            gameState.map = [];

            for (let p = 1; p <= 3; p++) {
                const name = document.getElementById(`p${p}name`).value || `Player ${p}`;
                const physical = document.querySelector(`input[name="p${p}physical"]:checked`).value;
                const verbal = document.querySelector(`input[name="p${p}verbal"]:checked`).value;
                const preventative = document.querySelector(`input[name="p${p}preventative"]:checked`).value;

                gameState.players.push({
                    id: p,
                    name: name,
                    dice: {
                        physical: createDie(physical),
                        verbal: createDie(verbal),
                        preventative: createDie(preventative)
                    }
                });
            }

            // Initialize talent state
            talentState.currentPlayer = 0;
            talentState.phase = 'best';
            talentState.playerRankings = [{}, {}, {}];

            // Hide setup, show talent screen
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('talentScreen').classList.remove('hidden');

            showTalentBestScreen();
        }

        function showTalentBestScreen() {
            const player = gameState.players[talentState.currentPlayer];
            document.getElementById('talentTitle').textContent = `${player.name}'s Best Talent`;
            document.getElementById('talentSubtitle').textContent =
                "You've picked the 3 things your character is good at. But which are they BEST at? Pick 1.";

            const categories = ['physical', 'verbal', 'preventative'];
            let html = '<div class="talent-options">';

            categories.forEach(cat => {
                const die = player.dice[cat];
                html += `
                    <button class="talent-btn ${cat}" onclick="selectBestTalent('${cat}')">
                        <span class="die-icon">${die.icon}</span>
                        <span class="die-name">${die.name}</span>
                        <span class="category-label">${cat.toUpperCase()}</span>
                    </button>
                `;
            });

            html += '</div>';
            html += '<p class="talent-hint">This die will get a powerful upgrade: replace a 2, 3, 4, or 5 with a 20!</p>';
            document.getElementById('talentContent').innerHTML = html;
        }

        function selectBestTalent(category) {
            talentState.playerRankings[talentState.currentPlayer].best = category;
            talentState.phase = 'worst';
            showTalentWorstScreen();
        }

        function showTalentWorstScreen() {
            const player = gameState.players[talentState.currentPlayer];
            const bestCat = talentState.playerRankings[talentState.currentPlayer].best;

            document.getElementById('talentTitle').textContent = `${player.name}'s Weakest Talent`;
            document.getElementById('talentSubtitle').textContent =
                "And which are they WORST at?";

            const categories = ['physical', 'verbal', 'preventative'].filter(c => c !== bestCat);
            let html = '<div class="talent-options">';

            categories.forEach(cat => {
                const die = player.dice[cat];
                html += `
                    <button class="talent-btn ${cat}" onclick="selectWorstTalent('${cat}')">
                        <span class="die-icon">${die.icon}</span>
                        <span class="die-name">${die.name}</span>
                        <span class="category-label">${cat.toUpperCase()}</span>
                    </button>
                `;
            });

            html += '</div>';
            html += '<p class="talent-hint" style="color:#f87171;">This die will get a downgrade: one of 2, 3, 4, or 5 becomes a 1...</p>';
            document.getElementById('talentContent').innerHTML = html;
        }

        function selectWorstTalent(category) {
            const ranking = talentState.playerRankings[talentState.currentPlayer];
            ranking.worst = category;

            // The middle one is whatever's left
            const categories = ['physical', 'verbal', 'preventative'];
            ranking.middle = categories.find(c => c !== ranking.best && c !== ranking.worst);

            // Move to next player or next phase
            talentState.currentPlayer++;

            if (talentState.currentPlayer >= 3) {
                // All players done with best/worst, now apply upgrades and show intertwine
                applyBestAndWorstUpgrades();
                talentState.currentPlayer = 0;
                talentState.phase = 'intertwine';
                showIntertwineScreen();
            } else {
                talentState.phase = 'best';
                showTalentBestScreen();
            }
        }

        function applyBestAndWorstUpgrades() {
            for (let i = 0; i < 3; i++) {
                const player = gameState.players[i];
                const ranking = talentState.playerRankings[i];

                // BEST die: replace a random 2-5 with 20
                const bestDie = player.dice[ranking.best];
                const lowFaces = [2, 3, 4, 5];
                const faceToUpgrade = lowFaces[Math.floor(Math.random() * lowFaces.length)];
                const faceIndex = bestDie.faces.indexOf(faceToUpgrade);
                if (faceIndex !== -1) {
                    bestDie.faces[faceIndex] = 20;
                }

                // WORST die: replace a random 2-5 with 1
                const worstDie = player.dice[ranking.worst];
                const remainingLowFaces = lowFaces.filter(f => worstDie.faces.includes(f));
                if (remainingLowFaces.length > 0) {
                    const faceToDowngrade = remainingLowFaces[Math.floor(Math.random() * remainingLowFaces.length)];
                    const downgradeIndex = worstDie.faces.indexOf(faceToDowngrade);
                    if (downgradeIndex !== -1) {
                        worstDie.faces[downgradeIndex] = 1;
                    }
                }
            }
        }

        function showIntertwineScreen() {
            const player = gameState.players[talentState.currentPlayer];
            const ranking = talentState.playerRankings[talentState.currentPlayer];
            const middleDie = player.dice[ranking.middle];

            document.getElementById('talentScreen').classList.add('hidden');
            document.getElementById('intertwineScreen').classList.remove('hidden');

            // Get allies (the two players who aren't the current player)
            const allies = gameState.players
                .map((p, idx) => ({ player: p, index: idx }))
                .filter(a => a.index !== talentState.currentPlayer);

            const currentAlly = allies[intertwineData.round - 1];
            const isFirstRound = intertwineData.round === 1;

            document.getElementById('intertwineSubtitle').textContent =
                `${player.name}, your ${middleDie.name} die will be intertwined with BOTH allies!`;

            let html = `
                <div class="intertwine-progress">
                    <span class="${isFirstRound ? 'active' : 'done'}">Link 1: ${isFirstRound ? currentAlly.player.name : allies[0].player.name}</span>
                    <span class="arrow">â†’</span>
                    <span class="${!isFirstRound ? 'active' : ''}">Link 2: ${allies[1].player.name}</span>
                </div>
                <div class="intertwine-step" id="intertwineStep1">
                    <h3>Choose a number between 6 and 10 for ${currentAlly.player.name}</h3>
                    <p>When you roll this number on your ${middleDie.name} die, it will trigger ${currentAlly.player.name}'s die instead!</p>
                    <div class="number-options">
            `;

            // Show available numbers (exclude already used ones)
            for (let n = 6; n <= 10; n++) {
                const used = intertwineData.usedNumbers.includes(n);
                html += `<button class="number-btn ${used ? 'disabled' : ''}" ${used ? 'disabled' : ''} onclick="selectIntertwineNumber(${n})">${n}</button>`;
            }

            html += `
                    </div>
                </div>
                <div class="intertwine-step hidden" id="intertwineStep2">
                    <h3>Choose which of ${currentAlly.player.name}'s dice</h3>
                    <div class="ally-dice-options" id="allyDiceOptions"></div>
                </div>
            `;

            document.getElementById('intertwineContent').innerHTML = html;
        }

        let intertwineData = { number: null, allyIndex: null, allyDieType: null, round: 1, usedNumbers: [] };

        function selectIntertwineNumber(num) {
            intertwineData.number = num;

            // Highlight selected
            document.querySelectorAll('.number-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');

            // Show dice selection (skip ally selection since it's predetermined)
            document.getElementById('intertwineStep2').classList.remove('hidden');

            // Get the current ally based on round
            const allies = gameState.players
                .map((p, idx) => ({ player: p, index: idx }))
                .filter(a => a.index !== talentState.currentPlayer);
            const currentAlly = allies[intertwineData.round - 1];
            intertwineData.allyIndex = currentAlly.index;

            let html = '';
            ['physical', 'verbal', 'preventative'].forEach(cat => {
                const die = currentAlly.player.dice[cat];
                html += `
                    <button class="talent-btn ${cat}" onclick="selectIntertwineAllyDie('${cat}')">
                        <span class="die-icon">${die.icon}</span>
                        <span class="die-name">${die.name}</span>
                    </button>
                `;
            });

            html += `<button class="confirm-btn" id="confirmIntertwine" onclick="confirmIntertwine()" style="display:none;">Lock It In!</button>`;
            document.getElementById('allyDiceOptions').innerHTML = html;
        }

        function selectIntertwineAllyDie(dieType) {
            intertwineData.allyDieType = dieType;

            // Highlight selected
            document.querySelectorAll('#allyDiceOptions .talent-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.closest('.talent-btn').classList.add('selected');

            // Show confirm button
            document.getElementById('confirmIntertwine').style.display = 'block';
        }

        function confirmIntertwine() {
            const player = gameState.players[talentState.currentPlayer];
            const ranking = talentState.playerRankings[talentState.currentPlayer];
            const middleDie = player.dice[ranking.middle];

            // Add the swap
            middleDie.swaps.push({
                faceValue: intertwineData.number,
                targetPlayer: intertwineData.allyIndex,
                targetDieType: intertwineData.allyDieType
            });

            // Track used number
            intertwineData.usedNumbers.push(intertwineData.number);

            if (intertwineData.round === 1) {
                // Move to second intertwine (other ally)
                intertwineData.round = 2;
                intertwineData.number = null;
                intertwineData.allyDieType = null;
                showIntertwineScreen();
            } else {
                // Both allies done, move to next player
                talentState.currentPlayer++;
                intertwineData = { number: null, allyIndex: null, allyDieType: null, round: 1, usedNumbers: [] };

                if (talentState.currentPlayer >= 3) {
                    // All done, start the game!
                    finishTalentRanking();
                } else {
                    showIntertwineScreen();
                }
            }
        }

        function finishTalentRanking() {
            document.getElementById('intertwineScreen').classList.add('hidden');

            // Save base faces for each die - these are the permanent upgrades from talent ranking
            // Temporary shop upgrades will be reset to these values between stages
            gameState.players.forEach(player => {
                Object.values(player.dice).forEach(die => {
                    die.baseFaces = [...die.faces];
                });
            });

            startGame();
        }

        // ==================== GAME INITIALIZATION ====================
        function startGame() {
            // If coming from talent ranking, players already exist with upgrades applied
            // Only create players if they don't exist yet
            if (gameState.players.length === 0) {
                gameState.gold = 0;
                gameState.doom = 0;
                gameState.hope = 0;
                gameState.map = [];

                for (let p = 1; p <= 3; p++) {
                    const name = document.getElementById(`p${p}name`).value || `Player ${p}`;
                    const physical = document.querySelector(`input[name="p${p}physical"]:checked`).value;
                    const verbal = document.querySelector(`input[name="p${p}verbal"]:checked`).value;
                    const preventative = document.querySelector(`input[name="p${p}preventative"]:checked`).value;

                    gameState.players.push({
                        id: p,
                        name: name,
                        dice: {
                            physical: createDie(physical),
                            verbal: createDie(verbal),
                            preventative: createDie(preventative)
                        }
                    });
                }
            }

            generateMap();

            // Hide all setup screens
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('talentScreen').classList.add('hidden');
            document.getElementById('intertwineScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');

            renderMap();
            renderPlayers();
            renderDiceTray();
            updateDoomHopeDisplay();
            updateFloorDisplay();

            gameState.map[0].status = 'available';
            renderMap();

            const stageInfo = STAGE_INFO[gameState.currentStage];
            document.getElementById('gameLog').innerHTML = '<h4>Log</h4>';
            log(`Stage ${gameState.currentStage}: ${stageInfo.name}`, 'info');
            log('Click to begin your journey...', 'info');
        }

        function createDie(type) {
            return {
                type: type,
                ...DICE_TYPES[type],
                faces: Array.from({length: 20}, (_, i) => i + 1),
                swaps: [], // Array of {faceValue, targetPlayer, targetDieType}
                hopeSegments: [], // Face values that grant HOPE when rolled
                crossedSegments: [], // Face values marked by Ferryman (one-time, triggers penalty)
                lastRoll: null
            };
        }

        function generateMap() {
            const stage = gameState.currentStage;

            // All stages use same encounter layout - players learn to strategize
            // Only Stage 5 has unique warped encounters
            // Stage structure: Intro â†’ 3-4 encounters â†’ Miniboss (halfway) â†’ 3-4 encounters â†’ Boss
            const COMMON_MAP_STRUCTURE = [
                // Start
                { encounter: 'start', row: 0 },
                // First 3-4 encounters (before miniboss)
                { encounter: 'mathematician', row: 1 },
                { encounter: 'bandits', row: 1 },
                { encounter: 'alchemist', row: 2 },
                { encounter: 'ferryman', row: 2 },
                { encounter: 'priest', row: 3 },
                { encounter: 'guards', row: 3 },
                // Miniboss (halfway point)
                { encounter: 'miniboss', row: 4 },
                // Second 3-4 encounters (after miniboss)
                { encounter: 'trapper', row: 5 },
                { encounter: 'gambler', row: 5 },
                { encounter: 'drunkPriest', row: 6 },
                { encounter: 'cultist', row: 6 },
                { encounter: 'bandits', row: 7 },
                { encounter: 'guards', row: 7 },
                // Boss
                { encounter: 'boss', row: 8 }
            ];

            const MAP_STRUCTURES = {
                1: COMMON_MAP_STRUCTURE,
                2: COMMON_MAP_STRUCTURE,
                3: COMMON_MAP_STRUCTURE,
                4: COMMON_MAP_STRUCTURE,
                // Stage 5: Same structure - Intro â†’ 3-4 encounters â†’ Miniboss â†’ 3-4 encounters â†’ Boss
                5: [
                    { encounter: 'start', row: 0 },
                    // First 3 encounters (before miniboss)
                    { encounter: 'fragment', row: 1 },
                    { encounter: 'echo', row: 1 },
                    { encounter: 'sanctuary', row: 2 },
                    { encounter: 'void', row: 2 },
                    { encounter: 'prophecy', row: 3 },
                    // Miniboss (halfway point)
                    { encounter: 'miniboss', row: 4 },
                    // Second 3 encounters (after miniboss)
                    { encounter: 'rift2', row: 5 },
                    { encounter: 'echo', row: 5 },
                    { encounter: 'sanctuary', row: 6 },
                    { encounter: 'void', row: 6 },
                    { encounter: 'fragment', row: 7 },
                    // Boss
                    { encounter: 'boss', row: 8 }
                ]
            };

            const structure = MAP_STRUCTURES[stage] || MAP_STRUCTURES[1];

            // Get the appropriate encounter source - only Stage 5 is different (warped)
            const encounterSource = stage === 5 ? STAGE_5_ENCOUNTERS : ENCOUNTERS;

            // Generate boss encounter for this stage
            const bossData = BOSSES[stage];
            const stageBoss = {
                type: 'boss',
                name: bossData.name,
                description: bossData.description,
                icon: 'ðŸ‘‘',
                dc: bossData.dc,
                reward: 50 + (stage * 25),
                successThresholds: bossData.successThresholds,
                attacksPerRound: bossData.attacksPerRound,
                options: [
                    { text: 'Attack! (Physical)', types: ['physical'], action: 'boss_combat' },
                    { text: 'Negotiate (Verbal)', types: ['verbal'], action: 'boss_combat' },
                    { text: 'Outmaneuver (Preventative)', types: ['preventative'], action: 'boss_combat' }
                ]
            };

            gameState.map = structure.map((node, index) => {
                let encounterData;
                if (node.encounter === 'boss') {
                    encounterData = stageBoss;
                } else {
                    encounterData = encounterSource[node.encounter] || ENCOUNTERS[node.encounter] || ENCOUNTERS.start;
                }

                return {
                    id: index,
                    ...encounterData,
                    encounterKey: node.encounter,
                    row: node.row,
                    status: index === 0 ? 'current' : 'locked',
                    connections: []
                };
            });

            // Build connections based on structure
            buildMapConnections(structure);
        }

        function buildMapConnections(structure) {
            // Group nodes by row
            const rowGroups = {};
            structure.forEach((node, idx) => {
                if (!rowGroups[node.row]) rowGroups[node.row] = [];
                rowGroups[node.row].push(idx);
            });

            const rows = Object.keys(rowGroups).sort((a, b) => a - b);

            // Connect each row to the next row
            for (let i = 0; i < rows.length - 1; i++) {
                const currentRow = rowGroups[rows[i]];
                const nextRow = rowGroups[rows[i + 1]];

                currentRow.forEach(nodeIdx => {
                    gameState.map[nodeIdx].connections = [...nextRow];
                });
            }
        }

        // ==================== RENDERING ====================
        function renderMap() {
            const container = document.getElementById('mapContainer');
            container.innerHTML = '';

            const rows = {};
            gameState.map.forEach(node => {
                if (!rows[node.row]) rows[node.row] = [];
                rows[node.row].push(node);
            });

            const rowKeys = Object.keys(rows).sort((a, b) => b - a);

            rowKeys.forEach((rowKey, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'map-row';

                rows[rowKey].forEach(node => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `map-node ${node.type} ${node.status}`;
                    nodeDiv.innerHTML = node.icon;
                    nodeDiv.title = node.name;

                    if (node.status === 'available') {
                        nodeDiv.onclick = () => selectNode(node.id);
                    }

                    rowDiv.appendChild(nodeDiv);
                });

                container.appendChild(rowDiv);

                if (rowIndex < rowKeys.length - 1) {
                    const pathDiv = document.createElement('div');
                    pathDiv.className = 'map-path';
                    container.appendChild(pathDiv);
                }
            });
        }

        function renderPlayers() {
            const container = document.getElementById('playersDisplay');
            container.innerHTML = '';

            gameState.players.forEach((player, idx) => {
                const card = document.createElement('div');
                card.className = `player-card player-${player.id}`;

                card.innerHTML = `
                    <h3>${player.name}</h3>
                    <div class="player-dice-mini">
                        ${Object.entries(player.dice).map(([type, die]) => {
                            const hasSwaps = die.swaps && die.swaps.length > 0;
                            const hasCrossed = die.crossedSegments && die.crossedSegments.length > 0;
                            return `
                                <div class="mini-die ${die.category}" title="${die.name}${hasSwaps ? ' (linked)' : ''}${hasCrossed ? ' (marked)' : ''}">
                                    ${die.icon}
                                    ${hasSwaps ? '<span class="swap-indicator">âŸ·</span>' : ''}
                                    ${hasCrossed ? '<span class="swap-indicator" style="background:#8b0000;">â¨‚</span>' : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function renderDiceTray() {
            const tray = document.getElementById('diceTray');
            tray.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                const group = document.createElement('div');
                group.className = `player-dice-group player-${player.id}`;
                group.innerHTML = `<h4>${player.name}</h4>`;

                const row = document.createElement('div');
                row.className = 'dice-row';

                Object.entries(player.dice).forEach(([type, die]) => {
                    const dieEl = document.createElement('div');
                    const hasSwaps = die.swaps && die.swaps.length > 0;
                    const hasCrossed = die.crossedSegments && die.crossedSegments.length > 0;
                    dieEl.className = `die ${die.category} player-${player.id}${hasSwaps ? ' has-swap' : ''}`;
                    dieEl.dataset.player = pIdx;
                    dieEl.dataset.type = type;

                    // Check if this player already rolled this round in boss combat
                    const state = gameState.encounterState;
                    const alreadyRolled = state?.type === 'boss_combat' &&
                                          state.playersRolledThisRound?.includes(pIdx);

                    const canUse = gameState.canRoll &&
                                   gameState.allowedDiceTypes.includes(die.category) &&
                                   player.hp > 0 &&
                                   !alreadyRolled;

                    if (!canUse) {
                        dieEl.classList.add('disabled');
                        if (alreadyRolled) {
                            dieEl.classList.add('already-rolled');
                        }
                    } else {
                        dieEl.onclick = () => rollDie(pIdx, type);
                    }

                    dieEl.innerHTML = `
                        <span class="die-name">${die.name}</span>
                        <span class="die-value">${die.lastRoll || 'd20'}</span>
                        ${hasSwaps ? `<span class="swap-badge">${die.swaps.length}</span>` : ''}
                        ${hasCrossed ? `<span class="swap-badge" style="background:#8b0000;left:-8px;right:auto;">â¨‚</span>` : ''}
                    `;

                    row.appendChild(dieEl);
                });

                group.appendChild(row);
                tray.appendChild(group);
            });
        }

        function updateDoomHopeDisplay() {
            document.getElementById('doomDisplay').textContent = gameState.doom;
            document.getElementById('hopeDisplay').textContent = gameState.hope;
            document.getElementById('goldDisplay').textContent = `${gameState.gold}G`;
        }

        // ==================== DOOM/HOPE SYSTEM ====================
        function addDoom(amount, reason = '') {
            gameState.doom += amount;
            updateDoomHopeDisplay();
            if (reason) {
                log(`+${amount} DOOM: ${reason}`, 'doom');
            }
        }

        function reduceDoom(amount) {
            const reduced = Math.min(gameState.doom, amount);
            gameState.doom -= reduced;
            updateDoomHopeDisplay();
            return reduced;
        }

        function addHope(amount) {
            if (gameState.doom > 0) {
                const reduced = Math.min(gameState.doom, amount);
                gameState.doom -= reduced;
                log(`HOPE offset ${reduced} DOOM!`, 'hope');
                updateDoomHopeDisplay();
            } else {
                log(`HOPE wasted (no DOOM to offset)`, 'info');
            }
        }

        function getEffectiveRoll(baseRoll) {
            // DOOM reduces all non-20 rolls
            if (baseRoll === 20) return 20;
            const effective = Math.max(1, baseRoll - gameState.doom);
            return effective;
        }

        function triggerDoomRoll(player, enemyName) {
            // DOOM Roll - the tension mechanic for enemy attacks
            const naturalRoll = Math.floor(Math.random() * 20) + 1;
            const effectiveRoll = getEffectiveRoll(naturalRoll);

            // Disable rolling during DOOM roll resolution
            gameState.canRoll = false;

            // Show the DOOM roll result with dramatic effect
            const doomRollResult = document.getElementById('rollResult');
            doomRollResult.classList.add('show');

            let outcomeText = '';
            let outcomeClass = '';

            if (effectiveRoll === 1) {
                // Journey ends
                outcomeText = `ðŸ’€ DOOM ROLL: ${naturalRoll}${naturalRoll !== effectiveRoll ? ` - ${gameState.doom} DOOM = ${effectiveRoll}` : ''}\n\nThe darkness claims you...`;
                outcomeClass = 'doom-death';
                document.getElementById('rollOutcome').innerHTML = outcomeText;
                document.getElementById('rollOutcome').className = outcomeClass;

                setTimeout(() => {
                    document.getElementById('defeatReason').textContent = `${player.name} succumbed to DOOM. The prophecy failed.`;
                    document.getElementById('defeatScreen').classList.remove('hidden');
                }, 2000);
                return;
            } else if (naturalRoll === 20) {
                // Divine favor - remove half DOOM
                const doomRemoved = Math.floor(gameState.doom / 2);
                reduceDoom(doomRemoved);
                outcomeText = `âœ¨ DOOM ROLL: NAT 20!\n\nDivine favor! -${doomRemoved} DOOM`;
                outcomeClass = 'doom-saved';
                log(`${player.name} rolled a NAT 20 on DOOM Roll! Removed ${doomRemoved} DOOM!`, 'crit');
            } else {
                // Survived but take damage
                const damage = Math.floor(Math.random() * 5) + 3;
                player.hp -= damage;
                outcomeText = `âš”ï¸ DOOM ROLL: ${naturalRoll}${naturalRoll !== effectiveRoll ? ` - ${gameState.doom} DOOM = ${effectiveRoll}` : ''}\n\n${enemyName} deals ${damage} damage!`;
                outcomeClass = effectiveRoll <= 5 ? 'doom-close' : 'doom-safe';
                log(`${player.name} survived DOOM Roll (${effectiveRoll}), took ${damage} damage.`, effectiveRoll <= 5 ? 'warn' : 'info');

                if (player.hp <= 0) {
                    player.hp = 0;
                    log(`${player.name} has fallen!`, 'fail');
                }

                if (gameState.players.every(p => p.hp <= 0)) {
                    setTimeout(() => {
                        document.getElementById('defeatScreen').classList.remove('hidden');
                    }, 1500);
                    return;
                }
            }

            document.getElementById('rollOutcome').innerHTML = outcomeText;
            document.getElementById('rollOutcome').className = outcomeClass;

            // Re-enable rolling after DOOM roll display
            setTimeout(() => {
                gameState.canRoll = true;
                renderPlayers();
                renderDiceTray();
            }, 1500);
        }

        function processBossRoundEnd(state) {
            // Determine number of attacks
            let numAttacks = state.attacksPerRound;
            if (Array.isArray(numAttacks)) {
                // Random range like [2, 3]
                numAttacks = Math.floor(Math.random() * (numAttacks[1] - numAttacks[0] + 1)) + numAttacks[0];
            }

            // Boss attacks based on misses (capped by numAttacks)
            const attacksToMake = Math.min(state.roundMisses, numAttacks);

            if (attacksToMake > 0) {
                log(`${state.enemyName} strikes ${attacksToMake} time(s)!`, 'doom');
                gameState.canRoll = false;

                // Execute DOOM rolls sequentially
                let attackIndex = 0;
                function executeNextAttack() {
                    if (attackIndex >= attacksToMake) {
                        // All attacks done, start next round
                        startNewBossRound(state);
                        return;
                    }

                    // Pick a random player who is still alive
                    const alivePlayers = gameState.players.filter(p => p.hp > 0);
                    if (alivePlayers.length === 0) return;

                    const targetPlayer = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];

                    triggerDoomRollForBoss(targetPlayer, state.enemyName, () => {
                        attackIndex++;
                        setTimeout(executeNextAttack, 500);
                    });
                }

                setTimeout(executeNextAttack, 1000);
            } else {
                // No misses, start next round
                log('All attacks landed! The boss staggers!', 'success');
                startNewBossRound(state);
            }
        }

        function startNewBossRound(state) {
            state.rollsThisRound = 0;
            state.roundMisses = 0;
            state.playersRolledThisRound = [];
            state.roundNumber++;
            gameState.canRoll = true;
            updateBossCombatUI();
            renderDiceTray();
            log(`--- Round ${state.roundNumber} ---`, 'info');
        }

        function triggerDoomRollForBoss(player, enemyName, callback) {
            // DOOM Roll variant that calls a callback when done
            const naturalRoll = Math.floor(Math.random() * 20) + 1;
            const effectiveRoll = getEffectiveRoll(naturalRoll);

            const doomRollResult = document.getElementById('rollResult');
            doomRollResult.classList.add('show');

            let outcomeText = '';
            let outcomeClass = '';

            if (effectiveRoll === 1) {
                outcomeText = `ðŸ’€ DOOM ROLL: ${naturalRoll}${naturalRoll !== effectiveRoll ? ` - ${gameState.doom} DOOM = ${effectiveRoll}` : ''}\n\nThe darkness claims ${player.name}...`;
                outcomeClass = 'doom-death';
                document.getElementById('rollOutcome').innerHTML = outcomeText;
                document.getElementById('rollOutcome').className = outcomeClass;

                setTimeout(() => {
                    document.getElementById('defeatReason').textContent = `${player.name} succumbed to DOOM. The prophecy failed.`;
                    document.getElementById('defeatScreen').classList.remove('hidden');
                }, 2000);
                return;
            } else if (naturalRoll === 20) {
                const doomRemoved = Math.floor(gameState.doom / 2);
                reduceDoom(doomRemoved);
                outcomeText = `âœ¨ DOOM ROLL: NAT 20!\n\nDivine favor! -${doomRemoved} DOOM`;
                outcomeClass = 'doom-saved';
                log(`${player.name} rolled NAT 20 on DOOM Roll! -${doomRemoved} DOOM!`, 'crit');
            } else {
                const damage = Math.floor(Math.random() * 5) + 3;
                player.hp -= damage;
                outcomeText = `âš”ï¸ DOOM ROLL: ${naturalRoll}${naturalRoll !== effectiveRoll ? ` - ${gameState.doom} DOOM = ${effectiveRoll}` : ''}\n\n${enemyName} deals ${damage} to ${player.name}!`;
                outcomeClass = effectiveRoll <= 5 ? 'doom-close' : 'doom-safe';
                log(`${player.name} survived (${effectiveRoll}), took ${damage} damage.`, effectiveRoll <= 5 ? 'warn' : 'info');

                if (player.hp <= 0) {
                    player.hp = 0;
                    log(`${player.name} has fallen!`, 'fail');
                }

                if (gameState.players.every(p => p.hp <= 0)) {
                    setTimeout(() => {
                        document.getElementById('defeatScreen').classList.remove('hidden');
                    }, 1500);
                    return;
                }
            }

            document.getElementById('rollOutcome').innerHTML = outcomeText;
            document.getElementById('rollOutcome').className = outcomeClass;

            setTimeout(() => {
                renderPlayers();
                if (callback) callback();
            }, 1500);
        }

        // ==================== ENCOUNTERS ====================
        function selectNode(nodeId) {
            const node = gameState.map[nodeId];
            if (node.status !== 'available') return;

            const currentNode = gameState.map.find(n => n.status === 'current');
            if (currentNode) currentNode.status = 'completed';

            node.status = 'current';
            gameState.currentNode = nodeId;
            gameState.currentEncounter = node;

            node.connections.forEach(connId => {
                if (gameState.map[connId].status === 'locked') {
                    gameState.map[connId].status = 'available';
                }
            });

            renderMap();
            showEncounter(node);
            log(`Entered: ${node.name}`, 'info');
        }

        function showEncounter(node) {
            document.getElementById('encounterTitle').textContent = node.name;
            document.getElementById('encounterDescription').innerHTML = `<p>${node.description}</p>`;

            const typeSpan = document.getElementById('encounterType');
            typeSpan.style.display = 'inline-block';
            typeSpan.className = `encounter-type ${node.type}`;
            typeSpan.textContent = node.type.toUpperCase();

            const optionsDiv = document.getElementById('encounterOptions');
            optionsDiv.innerHTML = '';

            // Check if this is a voting encounter
            if (node.vote && node.options) {
                startVoting(node);
                return;
            }

            if (node.options) {
                node.options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    if (opt.types) btn.classList.add(opt.types[0]);
                    if (opt.action.includes('swap')) btn.classList.add('swap');
                    btn.textContent = opt.text;

                    if (opt.cost && gameState.gold < opt.cost) {
                        btn.disabled = true;
                        btn.title = 'Not enough gold';
                    }

                    btn.onclick = () => handleOption(opt, node);
                    optionsDiv.appendChild(btn);
                });
            }

            gameState.encounterState = {};
            gameState.canRoll = false;
            gameState.allowedDiceTypes = ['physical', 'verbal', 'preventative'];
            renderDiceTray();
        }

        // ==================== VOTING SYSTEM ====================
        function startVoting(node) {
            gameState.voting = {
                active: true,
                options: node.options,
                votes: {},
                round: 1,
                node: node
            };
            renderVotingUI();
        }

        function renderVotingUI() {
            const optionsDiv = document.getElementById('encounterOptions');
            const v = gameState.voting;

            let voteStatus = `<div style="margin-bottom:15px; padding:10px; background:rgba(255,215,0,0.1); border-radius:8px; border:1px solid #ffd700;">
                <strong style="color:#ffd700;">VOTE (Round ${v.round}/2)</strong><br>
                <span style="color:#aaa;">Each player picks an option. Majority wins!</span>
            </div>`;

            // Show current votes
            gameState.players.forEach((player, pIdx) => {
                const voted = v.votes[pIdx] !== undefined;
                const votedFor = voted ? v.options[v.votes[pIdx]].text : 'Not voted';
                voteStatus += `<div style="margin:5px 0; color:${voted ? '#4ade80' : '#888'};">
                    ${player.name}: ${voted ? votedFor : '...'}</div>`;
            });

            optionsDiv.innerHTML = voteStatus;

            // Show voting buttons for each player
            gameState.players.forEach((player, pIdx) => {
                if (v.votes[pIdx] !== undefined) return; // Already voted

                const playerVoteDiv = document.createElement('div');
                playerVoteDiv.style.cssText = 'margin-top:15px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;';
                playerVoteDiv.innerHTML = `<strong style="color:#88ccff;">${player.name}'s Vote:</strong>`;

                const btnRow = document.createElement('div');
                btnRow.style.cssText = 'display:flex; gap:10px; margin-top:8px; flex-wrap:wrap;';

                v.options.forEach((opt, optIdx) => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.style.cssText = 'flex:1; min-width:120px;';
                    btn.textContent = opt.text;

                    if (opt.cost && gameState.gold < opt.cost) {
                        btn.disabled = true;
                        btn.title = 'Not enough gold';
                    }

                    btn.onclick = () => castVote(pIdx, optIdx);
                    btnRow.appendChild(btn);
                });

                playerVoteDiv.appendChild(btnRow);
                optionsDiv.appendChild(playerVoteDiv);
            });
        }

        function castVote(playerIdx, optionIdx) {
            gameState.voting.votes[playerIdx] = optionIdx;
            log(`${gameState.players[playerIdx].name} voted!`, 'info');

            // Check if all players have voted
            const voteCount = Object.keys(gameState.voting.votes).length;
            if (voteCount >= gameState.players.length) {
                resolveVote();
            } else {
                renderVotingUI();
            }
        }

        function resolveVote() {
            const v = gameState.voting;

            // Count votes
            const counts = {};
            Object.values(v.votes).forEach(optIdx => {
                counts[optIdx] = (counts[optIdx] || 0) + 1;
            });

            // Find winner(s)
            const maxVotes = Math.max(...Object.values(counts));
            const winners = Object.keys(counts).filter(k => counts[k] === maxVotes);

            if (winners.length === 1) {
                // Clear winner!
                const winningOption = v.options[parseInt(winners[0])];
                log(`Vote passed: "${winningOption.text}"`, 'success');
                gameState.voting.active = false;
                handleOption(winningOption, v.node);
            } else if (v.round === 1) {
                // Tie - vote again
                log('Tie! Vote again...', 'info');
                v.round = 2;
                v.votes = {};
                renderVotingUI();
            } else {
                // Second tie - random selection from tied options
                const randomWinner = winners[Math.floor(Math.random() * winners.length)];
                const winningOption = v.options[parseInt(randomWinner)];
                log(`Tie broken randomly: "${winningOption.text}"`, 'info');
                gameState.voting.active = false;
                handleOption(winningOption, v.node);
            }
        }

        function handleOption(option, node) {
            switch(option.action) {
                case 'leave':
                    completeEncounter();
                    break;
                case 'combat':
                    startCombat(option, node);
                    break;
                case 'upgrade_plus1':
                    showUpgradeModal(1); // Free!
                    break;
                case 'upgrade_plus2':
                    showUpgradeModal(2); // Free!
                    break;
                case 'math_free':
                    showUpgradeModal(2); // Free +2 to lowest face
                    break;
                case 'upgrade_plus3':
                    if (spendGold(option.cost)) showUpgradeModal(3);
                    break;
                case 'upgrade_plus5':
                    if (spendGold(option.cost)) showUpgradeModal(5);
                    break;
                case 'swap_low_to_ally':
                    showSwapModal('low'); // Free!
                    break;
                case 'swap_high_to_ally':
                    if (spendGold(option.cost)) showSwapModal('high');
                    break;
                case 'blessing_hope':
                    addHope(3);
                    log('The priest\'s blessing fills you with HOPE!', 'hope');
                    completeEncounter();
                    break;
                case 'blessing_greater':
                    addHope(5);
                    // Mark a random die with a crossed face
                    const randomP = gameState.players[Math.floor(Math.random() * 3)];
                    const randomDie = Object.values(randomP.dice)[Math.floor(Math.random() * 3)];
                    const markValue = Math.floor(Math.random() * 10) + 6; // 6-15
                    randomDie.crossedSegments.push(markValue);
                    log(`Greater blessing! +5 HOPE, but ${randomP.name}'s ${randomDie.name} is marked.`, 'hope');
                    completeEncounter();
                    break;
                case 'math_tradeoff':
                    // -1 from highest face, +4 to lowest
                    showMathTradeoffModal();
                    break;
                case 'alchemist_risky':
                    // Random swap + immediate +2 bonus
                    showRiskySwapModal();
                    break;
                case 'gamble_range':
                    // Range betting - generate random range, roll to see if in/out
                    const rangeStart = Math.floor(Math.random() * 8) + 5; // 5-12
                    const rangeEnd = rangeStart + Math.floor(Math.random() * 5) + 3; // +3 to +7
                    gameState.canRoll = true;
                    gameState.encounterState = {
                        type: 'gamble',
                        rangeMin: rangeStart,
                        rangeMax: Math.min(rangeEnd, 18),
                        inRangeReward: 5,
                        outRangeReward: 2
                    };
                    document.getElementById('encounterDescription').innerHTML = `
                        <p>The Gambler spins the wheel...</p>
                        <div style="margin-top:20px; padding:15px; background:rgba(255,215,0,0.15); border-radius:10px; border-left:4px solid #ffd700;">
                            <h3 style="color:#ffd700;">Target Range: ${rangeStart} - ${Math.min(rangeEnd, 18)}</h3>
                            <p><strong>IN RANGE:</strong> +5 to segment of choice!</p>
                            <p><strong>OUT OF RANGE:</strong> +2 to random segment</p>
                        </div>
                        <p style="margin-top:15px; color:#88ccff;">Roll any die!</p>
                    `;
                    document.getElementById('encounterOptions').innerHTML = '';
                    renderDiceTray();
                    break;
                case 'ferryman_roll':
                    handleFerrymanRoll();
                    break;
                case 'ferryman_paid':
                    if (spendGold(5)) {
                        addHope(2);
                        log('The Ferryman takes your gold and nods. "The river blesses you." +2 HOPE', 'hope');
                        completeEncounter();
                    } else {
                        log('Not enough gold! You need 5G.', 'fail');
                    }
                    break;
                case 'ferryman_wade':
                    addDoom(1, 'The cold waters chill your spirit');
                    log('You wade through the shallows safely, though the cold seeps into your bones.', 'info');
                    completeEncounter();
                    break;
                case 'trapper_trade':
                    showTrapperTrade();
                    break;
                case 'trapper_exotic':
                    showExoticDiceTrade();
                    break;
                case 'trapper_paid':
                    if (spendGold(8)) {
                        showTrapperPaidTrade();
                    } else {
                        log('Not enough gold! You need 8G.', 'fail');
                    }
                    break;
                case 'drunk_blessing':
                    handleDrunkBlessing();
                    break;
                case 'drunk_paid':
                    if (spendGold(3)) {
                        addHope(3);
                        log('The priest focuses intently. "BLESSINGS!" A perfect blessing lands. +3 HOPE!', 'hope');
                        completeEncounter();
                    } else {
                        log('Not enough gold! You need 3G.', 'fail');
                    }
                    break;
                case 'cultist_drink':
                    handleCultistDrink();
                    break;
                case 'cultist_paid':
                    if (spendGold(10)) {
                        handleCultistPaid();
                    } else {
                        log('Not enough gold! You need 10G.', 'fail');
                    }
                    break;
                case 'blessing_segment':
                    showBlessSegmentModal();
                    break;
                case 'alchemist_double':
                    showDoubleLinkModal();
                    break;
                case 'gamble_range_choice':
                    showGambleRangeChoice();
                    break;
                case 'boss_combat':
                    startBossCombat(option, node);
                    break;
                // Stage 5 warped encounter actions
                case 'restore_die':
                    // Reset a random damaged face on a random die
                    const randomPlayer = gameState.players[Math.floor(Math.random() * 3)];
                    const dieTypes = ['physical', 'verbal', 'preventative'];
                    const randomDieType = dieTypes[Math.floor(Math.random() * 3)];
                    const randomDie = randomPlayer.dice[randomDieType];
                    // Find a face that's been reduced to 1 and restore it
                    const oneIdx = randomDie.faces.indexOf(1);
                    if (oneIdx > 0) {
                        randomDie.faces[oneIdx] = oneIdx + 1;
                        log(`${randomPlayer.name}'s ${randomDie.name} is partially restored!`, 'success');
                    } else {
                        log('The fragment pulses but finds nothing to heal.', 'info');
                    }
                    completeEncounter();
                    break;
                case 'sanctuary_rest':
                    addHope(2);
                    log('A moment of peace in the chaos. The party gathers strength. +2 HOPE', 'success');
                    completeEncounter();
                    break;
                case 'accept_destiny':
                    addHope(3);
                    log('You are the chosen ones. The 20th prophecy will succeed.', 'crit');
                    completeEncounter();
                    break;
                case 'rift_touch':
                    addHope(1);
                    log('Warmth flows through the tear. You feel hope. +1 HOPE', 'hope');
                    completeEncounter();
                    break;
            }
        }

        function startBossCombat(option, node) {
            const stage = gameState.currentStage || 1;
            const bossData = BOSSES[stage];

            gameState.canRoll = true;
            gameState.targetDC = bossData.dc;
            gameState.allowedDiceTypes = option.types;
            gameState.encounterState = {
                type: 'boss_combat',
                enemyName: bossData.name,
                reward: node.reward,
                successThresholds: { ...bossData.successThresholds },
                successCounters: { physical: 0, verbal: 0, preventative: 0 },
                attacksPerRound: bossData.attacksPerRound,
                chosenApproach: option.types[0], // physical, verbal, or preventative
                roundMisses: 0,
                rollsThisRound: 0,
                playersRolledThisRound: [], // Track which players have rolled
                roundNumber: 1
            };

            updateBossCombatUI();
            document.getElementById('encounterOptions').innerHTML = '';
            renderDiceTray();
        }

        function updateBossCombatUI() {
            const state = gameState.encounterState;
            if (!state || state.type !== 'boss_combat') return;

            const stage = gameState.currentStage || 1;
            const bossData = BOSSES[stage];
            const threshold = state.successThresholds[state.chosenApproach];

            // Build list of who still needs to roll
            const needToRoll = gameState.players
                .filter((p, idx) => !state.playersRolledThisRound.includes(idx) && p.hp > 0)
                .map(p => p.name);

            const waitingText = needToRoll.length > 0
                ? `<strong>${needToRoll.join(', ')}</strong> - your turn to roll!`
                : 'Round complete!';

            document.getElementById('encounterDescription').innerHTML = `
                <p>${bossData.description}</p>
                <div style="margin-top:20px; padding:15px; background:rgba(139,0,139,0.2); border-radius:10px; border-left:4px solid #9333ea;">
                    <h3 style="color:#c084fc;">ðŸ‘‘ ${bossData.name}</h3>
                    <div id="bossSuccessDisplay" style="margin:15px 0;">
                        <p style="font-size:1.1rem;">
                            <span style="color:#4ade80;">âœ“</span> <strong>${state.chosenApproach.toUpperCase()}</strong> Progress:
                            <span id="successCounter" style="color:#4ade80; font-size:1.3rem;">${state.successCounters[state.chosenApproach]}</span> / ${threshold}
                        </p>
                    </div>
                    <div style="background:rgba(0,0,0,0.3); padding:10px; border-radius:5px; margin:10px 0;">
                        <p style="color:#ffd700; margin:0;">Round ${state.roundNumber} â€¢ Roll ${state.rollsThisRound + 1}/3</p>
                        <p style="color:#88ccff; margin:5px 0 0 0; font-size:0.95rem;">${waitingText}</p>
                    </div>
                    <p style="color:#aaa; font-size:0.9rem;">DC to succeed: ${bossData.dc}</p>
                </div>
            `;
        }

        function startCombat(option, node) {
            gameState.canRoll = true;
            gameState.targetDC = node.dc;
            // All dice types are always available
            gameState.allowedDiceTypes = ['physical', 'verbal', 'preventative'];

            // Use success thresholds like boss combat
            const thresholds = node.successThresholds || { physical: 2, verbal: 2, preventative: 2 };

            gameState.encounterState = {
                type: 'combat',
                enemyName: node.name,
                reward: node.reward,
                successThresholds: { ...thresholds },
                successCounters: { physical: 0, verbal: 0, preventative: 0 },
                isBoss: node.type === 'boss'
            };

            updateCombatUI(node);
            document.getElementById('encounterOptions').innerHTML = '';
            renderDiceTray();
        }

        function updateCombatUI(node) {
            const state = gameState.encounterState;
            const thresholds = state.successThresholds;
            const counters = state.successCounters;

            // Build "balls and strikes" style progress display
            const buildProgress = (type, color) => {
                const needed = thresholds[type];
                const current = counters[type];
                let dots = '';
                for (let i = 0; i < needed; i++) {
                    dots += i < current ? 'â—' : 'â—‹';
                }
                return `<span style="color:${color};">${type.charAt(0).toUpperCase() + type.slice(1)}: ${dots}</span>`;
            };

            document.getElementById('encounterDescription').innerHTML = `
                <p>${node.description}</p>
                <div style="margin-top:20px; padding:15px; background:rgba(255,50,50,0.15); border-radius:10px; border-left:4px solid #f87171;">
                    <h3 style="color:#f87171;">${node.name}</h3>
                    <p style="color:#aaa; margin-bottom:10px;">DC to hit: ${gameState.targetDC}</p>
                    <div id="combatProgress" style="font-size:1.1rem; display:flex; flex-direction:column; gap:8px;">
                        ${buildProgress('physical', '#c45c26')}
                        ${buildProgress('verbal', '#2980b9')}
                        ${buildProgress('preventative', '#8e44ad')}
                    </div>
                </div>
                <p style="margin-top:15px; color:#88ccff;">Roll any die to make progress! Fill a bar to win!</p>
            `;
        }

        function refreshCombatProgress() {
            const state = gameState.encounterState;
            if (!state || state.type !== 'combat') return;

            const thresholds = state.successThresholds;
            const counters = state.successCounters;

            const buildProgress = (type, color) => {
                const needed = thresholds[type];
                const current = counters[type];
                let dots = '';
                for (let i = 0; i < needed; i++) {
                    dots += i < current ? 'â—' : 'â—‹';
                }
                return `<span style="color:${color};">${type.charAt(0).toUpperCase() + type.slice(1)}: ${dots}</span>`;
            };

            const progressDiv = document.getElementById('combatProgress');
            if (progressDiv) {
                progressDiv.innerHTML = `
                    ${buildProgress('physical', '#c45c26')}
                    ${buildProgress('verbal', '#2980b9')}
                    ${buildProgress('preventative', '#8e44ad')}
                `;
            }
        }

        // ==================== DICE ROLLING ====================
        function rollDie(playerIndex, dieType) {
            if (!gameState.canRoll) return;

            const player = gameState.players[playerIndex];
            const die = player.dice[dieType];

            if (!gameState.allowedDiceTypes.includes(die.category)) {
                log(`Can't use ${die.name} here!`, 'fail');
                return;
            }

            const dieElement = document.querySelector(`[data-player="${playerIndex}"][data-type="${dieType}"]`);
            dieElement.classList.add('rolling');

            setTimeout(() => {
                dieElement.classList.remove('rolling');
                const faceIndex = Math.floor(Math.random() * 20);
                let result = die.faces[faceIndex];

                // Check for swaps
                const swap = die.swaps.find(s => s.faceValue === result);
                let swapInfo = null;

                if (swap) {
                    // Trigger the swapped die!
                    const targetPlayer = gameState.players[swap.targetPlayer];
                    const targetDie = targetPlayer.dice[swap.targetDieType];
                    const swapRoll = targetDie.faces[Math.floor(Math.random() * 20)];

                    swapInfo = {
                        originalRoll: result,
                        swappedTo: targetPlayer.name,
                        swappedDie: targetDie.name,
                        newRoll: swapRoll
                    };

                    result = swapRoll;
                    log(`SWAP! ${result} triggered ${targetPlayer.name}'s ${targetDie.name}!`, 'swap');
                }

                // Check for Ferryman's crossed segments (one-time penalty)
                let crossedTriggered = false;
                const crossedIdx = die.crossedSegments.indexOf(result);
                if (crossedIdx !== -1) {
                    crossedTriggered = true;
                    // Remove it (one-time only)
                    die.crossedSegments.splice(crossedIdx, 1);
                    log(`CROSSED! The Ferryman's mark activates on ${result}!`, 'doom');
                }

                die.lastRoll = result;
                showRollResult(playerIndex, player, die, result, swapInfo, crossedTriggered);
            }, 600);
        }

        function showRollResult(playerIndex, player, die, result, swapInfo = null, crossedTriggered = false) {
            const modal = document.getElementById('rollResult');
            const valueEl = document.getElementById('rollValue');
            const outcomeEl = document.getElementById('rollOutcome');
            const swapEl = document.getElementById('swapTriggered');
            const doomChangeEl = document.getElementById('doomChange');

            document.getElementById('rollDieName').textContent = `${player.name}'s ${die.name}`;

            // Show swap info if applicable
            if (swapInfo) {
                swapEl.style.display = 'block';
                swapEl.innerHTML = `Rolled ${swapInfo.originalRoll} â†’ Linked to ${swapInfo.swappedTo}'s ${swapInfo.swappedDie}!`;
            } else if (crossedTriggered) {
                swapEl.style.display = 'block';
                swapEl.innerHTML = `<span style="color:#ff6b6b;">â¨‚ FERRYMAN'S MARK! The crossed face triggered!</span>`;
            } else {
                swapEl.style.display = 'none';
            }

            // DOOM does NOT affect regular player rolls - only DOOM rolls!
            // Regular rolls use the raw result
            valueEl.textContent = result;
            doomChangeEl.style.display = 'none';

            // Handle crossed segment penalty
            let crossedDoomPenalty = 0;
            if (crossedTriggered) {
                crossedDoomPenalty = 2;
                addDoom(crossedDoomPenalty, 'Ferryman\'s mark triggered');
            }

            valueEl.className = 'result-value';
            let doomDelta = 0;

            if (result === 20) {
                valueEl.classList.add('crit');
                outcomeEl.textContent = 'NATURAL 20!';
                // Nat 20 adds +1 HOPE
                addHope(1);
                doomChangeEl.style.display = 'block';
                doomChangeEl.className = 'doom-change hope-up';
                doomChangeEl.textContent = '+1 HOPE from Natural 20!';
                doomChangeEl.style.color = '#ffd700';
            } else if (result === 1) {
                valueEl.classList.add('fail');
                outcomeEl.textContent = 'CRITICAL FAIL!';
                // Nat 1 adds +1 DOOM
                addDoom(1, 'Natural 1');
                doomChangeEl.style.display = 'block';
                doomChangeEl.className = 'doom-change doom-up';
                doomChangeEl.textContent = '+1 DOOM from Natural 1!';
                doomChangeEl.style.color = '#ff6b6b';
            } else if (result >= gameState.targetDC) {
                valueEl.classList.add('success');
                outcomeEl.textContent = 'Success!';
            } else {
                valueEl.classList.add('fail');
                outcomeEl.textContent = 'Failed...';
            }

            // Check for HOPE on this segment
            if (die.hopeSegments && die.hopeSegments.includes(result)) {
                addHope(1);
            }

            modal.classList.add('show');
            processRollResult(playerIndex, player, die, result, doomDelta);
        }

        function processRollResult(playerIndex, player, die, result, doomDelta) {
            const state = gameState.encounterState;

            if (state.type === 'combat') {
                // Which approach did they use? Based on the die category
                const approach = die.category;
                const threshold = state.successThresholds[approach];

                // DOOM does NOT affect regular rolls - use raw result
                if (result >= gameState.targetDC || result === 20) {
                    // Success! Track progress in that approach
                    state.successCounters[approach]++;
                    const current = state.successCounters[approach];

                    log(`${player.name}'s ${die.name} scores a success! (${current}/${threshold} ${approach})`, result === 20 ? 'crit' : 'success');

                    // Update the visual progress
                    refreshCombatProgress();

                    // Check for victory - any approach reaching its threshold wins
                    if (current >= threshold) {
                        gameState.canRoll = false;
                        document.getElementById('rollOutcome').textContent += ' VICTORY!';
                        addGold(state.reward);
                        log(`${state.enemyName} defeated! +${state.reward} gold`, 'crit');

                        if (state.isBoss) {
                            setTimeout(showBossVictory, 1500);
                        } else {
                            setTimeout(completeEncounter, 1500);
                        }
                    }
                } else {
                    // Miss - trigger DOOM Roll!
                    log(`Miss! ${state.enemyName} retaliates!`, 'fail');
                    triggerDoomRoll(player, state.enemyName);
                }
            } else if (state.type === 'gamble') {
                // Craps-style range betting
                const inRange = result >= state.rangeMin && result <= state.rangeMax;
                const betIn = state.bet === 'in';
                const won = (inRange && betIn) || (!inRange && !betIn);

                if (won) {
                    // They won their bet! Better reward
                    const reward = inRange ? state.inRangeReward : state.outRangeReward;
                    log(`YOU WIN! +${reward} to a segment of your choice!`, 'crit');
                    showUpgradeModal(reward);
                } else {
                    // They lost their bet, but still get consolation prize
                    const reward = inRange ? state.inRangeReward : state.outRangeReward;
                    log(`Close! You still get +${reward} to a random segment.`, 'success');
                    applyRandomUpgrade(reward);
                    setTimeout(completeEncounter, 1500);
                }
                gameState.canRoll = false;
            } else if (state.type === 'boss_combat') {
                state.rollsThisRound++;
                state.playersRolledThisRound.push(playerIndex);
                const threshold = state.successThresholds[state.chosenApproach];

                if (result >= gameState.targetDC || result === 20) {
                    // Success!
                    state.successCounters[state.chosenApproach]++;
                    const current = state.successCounters[state.chosenApproach];

                    log(`${player.name}'s ${die.name} scores a success! (${current}/${threshold})`, result === 20 ? 'crit' : 'success');

                    // Check for victory
                    if (current >= threshold) {
                        gameState.canRoll = false;
                        document.getElementById('rollOutcome').textContent += ' VICTORY!';
                        log(`The party defeats ${state.enemyName}!`, 'crit');
                        addGold(state.reward);

                        setTimeout(showBossVictory, 1500);
                        return;
                    }
                } else {
                    // Miss - track for DOOM rolls at end of round
                    state.roundMisses++;
                    log(`${player.name} misses! (${state.roundMisses} miss this round)`, 'fail');
                }

                // Update the UI to show who still needs to roll
                updateBossCombatUI();
                renderDiceTray();

                // Check if all 3 players have rolled this round
                if (state.rollsThisRound >= 3) {
                    // End of round - process boss attacks for misses
                    processBossRoundEnd(state);
                }
            } else if (state.type === 'ferryman') {
                let narrative = '';
                if (result >= 15) {
                    narrative = 'The Ferryman grins as luck favors him. Swift passage!';
                    addGold(10);
                } else if (result >= 10) {
                    narrative = 'The Ferryman nods. A fair crossing.';
                } else if (result >= 5) {
                    narrative = 'The Ferryman winces. The boat rocks dangerously...';
                    addDoom(1, 'Rough crossing');
                } else {
                    narrative = 'The Ferryman howls! He barely survives the crossing.';
                    addDoom(2, 'Terrible crossing');
                }

                // Create a temporary swap as payment
                createRandomSwap(player, die);
                log(narrative, result >= 10 ? 'success' : 'fail');
                document.getElementById('rollOutcome').textContent = narrative;
                gameState.canRoll = false;
                setTimeout(completeEncounter, 2000);
            }

            renderDiceTray();
        }

        function closeRollResult() {
            document.getElementById('rollResult').classList.remove('show');
        }

        function completeEncounter() {
            document.getElementById('encounterTitle').textContent = 'Choose your path';
            document.getElementById('encounterType').style.display = 'none';
            document.getElementById('encounterDescription').innerHTML = '<p>Select an available location on the map.</p>';
            document.getElementById('encounterOptions').innerHTML = '';
            gameState.canRoll = false;
            gameState.currentEncounter = null;
            renderDiceTray();
        }

        // ==================== DICE SWAPPING ====================
        function createRandomSwap(player, die) {
            // Pick a random low face (1-5) to swap
            const lowFaces = die.faces.filter(f => f <= 5);
            if (lowFaces.length === 0) return;

            const faceToSwap = lowFaces[Math.floor(Math.random() * lowFaces.length)];

            // Pick a random other player and die
            const otherPlayers = gameState.players.filter(p => p.id !== player.id);
            const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const targetDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];

            die.swaps.push({
                faceValue: faceToSwap,
                targetPlayer: gameState.players.indexOf(targetPlayer),
                targetDieType: targetDieType
            });

            log(`${die.name} now linked: ${faceToSwap} â†’ ${targetPlayer.name}'s ${targetPlayer.dice[targetDieType].name}`, 'swap');
            renderPlayers();
            renderDiceTray();
        }

        function showSwapModal(type) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');

            const isLow = type === 'low';
            document.getElementById('upgradeTitle').textContent = isLow ?
                'Link a Low Roll to Ally' : 'Link a High Roll to Ally';
            document.getElementById('upgradeDescription').textContent = isLow ?
                'Choose a die, then pick a low number (1-5) to link to a teammate\'s die:' :
                'Choose a die, then pick a high number (16-19) to link to a teammate\'s die:';

            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([dieType, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option swap-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Click to add a swap link</p>
                    `;
                    opt.onclick = () => showSwapTargetPicker(pIdx, dieType, isLow);
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showSwapTargetPicker(sourcePlayerIdx, sourceDieType, isLow) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');
            const sourcePlayer = gameState.players[sourcePlayerIdx];
            const sourceDie = sourcePlayer.dice[sourceDieType];

            const range = isLow ? [1,2,3,4,5] : [16,17,18,19];

            document.getElementById('upgradeTitle').textContent = 'Choose Face & Target';
            document.getElementById('upgradeDescription').textContent =
                `Select which face of ${sourcePlayer.name}'s ${sourceDie.name} to link:`;

            options.innerHTML = '';

            range.forEach(faceValue => {
                // For each possible target
                gameState.players.forEach((targetPlayer, tpIdx) => {
                    if (tpIdx === sourcePlayerIdx) return;

                    Object.entries(targetPlayer.dice).forEach(([targetDieType, targetDie]) => {
                        const opt = document.createElement('div');
                        opt.className = 'upgrade-option swap-option';
                        opt.innerHTML = `
                            <h4>Roll ${faceValue} â†’ ${targetPlayer.name}'s ${targetDie.name}</h4>
                            <p>When you roll ${faceValue}, ${targetPlayer.name}'s ${targetDie.name} activates instead</p>
                        `;
                        opt.onclick = () => {
                            sourceDie.swaps.push({
                                faceValue: faceValue,
                                targetPlayer: tpIdx,
                                targetDieType: targetDieType
                            });
                            log(`Linked! ${sourceDie.name} ${faceValue} â†’ ${targetPlayer.name}'s ${targetDie.name}`, 'swap');
                            modal.classList.remove('show');
                            renderPlayers();
                            renderDiceTray();
                            completeEncounter();
                        };
                        options.appendChild(opt);
                    });
                });
            });
        }

        // ==================== UPGRADES ====================
        function showUpgradeModal(amount) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');

            document.getElementById('upgradeTitle').textContent = `Add +${amount} to a Die`;
            document.getElementById('upgradeDescription').textContent = 'Choose which die to upgrade:';

            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Lowest face: ${Math.min(...die.faces)}</p>
                    `;
                    opt.onclick = () => {
                        const minIdx = die.faces.indexOf(Math.min(...die.faces));
                        die.faces[minIdx] += amount;
                        log(`Upgraded ${player.name}'s ${die.name}!`, 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function applyRandomUpgrade(amount) {
            // Apply upgrade to a random player's random die
            const randomPlayer = gameState.players[Math.floor(Math.random() * 3)];
            const dieTypes = Object.keys(randomPlayer.dice);
            const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
            const die = randomPlayer.dice[randomDieType];

            const minIdx = die.faces.indexOf(Math.min(...die.faces));
            die.faces[minIdx] += amount;
            log(`${randomPlayer.name}'s ${die.name} gets +${amount}!`, 'success');
            renderDiceTray();
        }

        function showMathTradeoffModal() {
            // -1 from highest face, +4 to lowest on same die
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'Advanced Mathematics';
            document.getElementById('upgradeDescription').textContent = 'Sacrifice -1 from highest face to gain +4 on lowest:';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const minVal = Math.min(...die.faces);
                    const maxVal = Math.max(...die.faces);
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>High: ${maxVal} â†’ ${maxVal - 1}</p>
                        <p>Low: ${minVal} â†’ ${minVal + 4}</p>
                    `;
                    opt.onclick = () => {
                        const maxIdx = die.faces.indexOf(maxVal);
                        const minIdx = die.faces.indexOf(minVal);
                        die.faces[maxIdx] -= 1;
                        die.faces[minIdx] += 4;
                        log(`${player.name}'s ${die.name}: ${maxVal}â†’${maxVal-1}, ${minVal}â†’${minVal+4}!`, 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showRiskySwapModal() {
            // Random swap + +2 bonus to that die
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'Risky Alchemy';
            document.getElementById('upgradeDescription').textContent = 'Link a random segment to an ally, but get +2 bonus:';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Random swap + immediate +2</p>
                    `;
                    opt.onclick = () => {
                        // Create a random swap
                        const swapValue = Math.floor(Math.random() * 15) + 3; // 3-17
                        const otherPlayers = gameState.players.filter((_, i) => i !== pIdx);
                        const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
                        const targetDieTypes = Object.keys(targetPlayer.dice);
                        const targetDieType = targetDieTypes[Math.floor(Math.random() * targetDieTypes.length)];

                        die.swaps.push({
                            faceValue: swapValue,
                            targetPlayer: gameState.players.indexOf(targetPlayer),
                            targetDieType: targetDieType
                        });

                        // Apply +2 bonus
                        const minIdx = die.faces.indexOf(Math.min(...die.faces));
                        die.faces[minIdx] += 2;

                        log(`Risky splice! ${swapValue} on ${die.name} â†’ ${targetPlayer.name}'s ${targetPlayer.dice[targetDieType].name}, plus +2!`, 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showTrapperPaidTrade() {
            // Paid version - guaranteed +6 to +10 to lowest face
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Trapper\'s Premium Collection';
            document.getElementById('upgradeDescription').textContent = 'Choose a die - its lowest face gets +6 to +10:';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const minVal = Math.min(...die.faces);
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Upgrade: ${minVal}</p>
                    `;
                    opt.onclick = () => {
                        const minIdx = die.faces.indexOf(minVal);
                        const bonus = Math.floor(Math.random() * 5) + 6; // +6 to +10
                        const newVal = Math.min(20, minVal + bonus);
                        die.faces[minIdx] = newVal;
                        log(`Premium trade! ${die.name}: ${minVal} â†’ ${newVal} (+${bonus})`, 'crit');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function handleCultistPaid() {
            // Paid version - guaranteed good outcome (swap + upgrade)
            const randomPlayer = gameState.players[Math.floor(Math.random() * gameState.players.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
            const die = randomPlayer.dice[randomDieType];

            createRandomSwap(randomPlayer, die);

            // Upgrade: +5 to lowest face
            const minVal = Math.min(...die.faces);
            const minIdx = die.faces.indexOf(minVal);
            die.faces[minIdx] += 5;

            log(`The sacred herb reveals pure visions! ${die.name} lowest face ${minVal} â†’ ${minVal + 5}`, 'crit');
            log('Your fates are intertwined with your allies!', 'success');

            renderDiceTray();
            completeEncounter();
        }

        function showTrapperTrade() {
            // Trapper uses weighted outcomes: 7/15 good, 4/15 neutral, 4/15 bad
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Trapper\'s Trade';
            document.getElementById('upgradeDescription').textContent = 'Choose a die to trade its lowest face for a mystery value:';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const minVal = Math.min(...die.faces);
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Trade away: ${minVal}</p>
                    `;
                    opt.onclick = () => {
                        const minIdx = die.faces.indexOf(minVal);
                        const outcome = getNeutralOutcome();
                        let newVal;

                        if (outcome === 'good') {
                            // Good: Get a value that's definitely better (minVal + 5 to 20)
                            newVal = Math.min(20, minVal + 5 + Math.floor(Math.random() * (16 - minVal)));
                            log(`Great trade! ${die.name}: ${minVal} â†’ ${newVal}`, 'crit');
                        } else if (outcome === 'neutral') {
                            // Neutral: Get a value close to what you had (minVal-2 to minVal+3)
                            newVal = Math.max(1, Math.min(20, minVal + Math.floor(Math.random() * 6) - 2));
                            log(`Fair trade. ${die.name}: ${minVal} â†’ ${newVal}`, 'info');
                        } else {
                            // Bad: Get a worse value (1 to minVal-1, or 1 if already 1)
                            newVal = minVal > 1 ? Math.floor(Math.random() * (minVal - 1)) + 1 : 1;
                            log(`Bad trade... ${die.name}: ${minVal} â†’ ${newVal}`, 'fail');
                        }

                        die.faces[minIdx] = newVal;
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        // ==================== SPECIAL ENCOUNTERS ====================
        // Neutral encounters use weighted randomness: ~7/15 good, ~4/15 neutral, ~4/15 bad
        function getNeutralOutcome() {
            const roll = Math.random() * 15;
            if (roll < 7) return 'good';      // ~47% - good outcome
            if (roll < 11) return 'neutral';  // ~27% - neutral outcome
            return 'bad';                      // ~27% - bad outcome
        }

        function handleFerrymanRoll() {
            // Roll-based encounter with 7/15 good, 4/15 neutral, 4/15 bad
            const outcome = getNeutralOutcome();

            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Ferryman\'s Judgment';

            if (outcome === 'good') {
                // Good: +2 HOPE and safe passage
                document.getElementById('upgradeDescription').textContent =
                    'The waters glow with approval! The Ferryman smiles. "The river blesses you."';
                addHope(2);
                log('The Ferryman grants safe passage with the river\'s blessing! +2 HOPE', 'hope');
            } else if (outcome === 'neutral') {
                // Neutral: Just safe passage, nothing more
                document.getElementById('upgradeDescription').textContent =
                    'The Ferryman nods. "The river accepts. You may pass." Nothing more, nothing less.';
                log('Safe passage granted. The river remains indifferent.', 'info');
            } else {
                // Bad: One random die gets a crossed mark (triggers DOOM once)
                document.getElementById('upgradeDescription').textContent =
                    'The river churns darkly. "A toll must be paid..." One of your dice bears the Ferryman\'s mark.';

                // Pick a random player and die to mark
                const randomPlayer = gameState.players[Math.floor(Math.random() * 3)];
                const dieTypes = ['physical', 'verbal', 'preventative'];
                const randomDieType = dieTypes[Math.floor(Math.random() * 3)];
                const die = randomPlayer.dice[randomDieType];

                // Mark a higher number (11-18)
                const crossedFace = Math.floor(Math.random() * 8) + 11;
                die.crossedOut = die.crossedOut || [];
                die.crossedOut.push(crossedFace);

                log(`${randomPlayer.name}'s ${die.name} is marked! Rolling ${crossedFace} triggers +2 DOOM (once).`, 'fail');
            }

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '<div class="upgrade-option" onclick="document.getElementById(\'upgradeModal\').classList.remove(\'show\'); completeEncounter();"><h4>Continue</h4></div>';
            modal.classList.add('show');
        }

        // Legacy function - replaced by handleFerrymanRoll
        function handleFerrymanMark_DEPRECATED() {
            // Each player selects one die to be marked by the Ferryman
            // That die gets a "crossed" segment (weighted to higher numbers)
            // When rolled, it triggers once and causes a penalty

            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Ferryman\'s Mark';
            document.getElementById('upgradeDescription').textContent =
                'Each hero must offer one die to be marked. The Ferryman will cross out a face (weighted toward higher numbers). If you roll that face, something bad happens - once.';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            // Track which players have chosen
            if (!gameState.ferrymanChoices) {
                gameState.ferrymanChoices = {};
            }

            // Show status
            const statusDiv = document.createElement('div');
            statusDiv.style.cssText = 'margin-bottom:15px; padding:10px; background:rgba(100,100,200,0.1); border-radius:8px;';
            statusDiv.innerHTML = gameState.players.map(p => {
                const chosen = gameState.ferrymanChoices[p.id];
                return `<div style="color:${chosen ? '#4ade80' : '#888'}">${p.name}: ${chosen ? chosen : '...'}</div>`;
            }).join('');
            options.appendChild(statusDiv);

            // Show options for players who haven't chosen yet
            gameState.players.forEach((player, pIdx) => {
                if (gameState.ferrymanChoices[player.id]) return;

                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'margin-top:10px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;';
                playerDiv.innerHTML = `<strong style="color:#88ccff;">${player.name}, choose a die:</strong>`;

                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.style.cssText = 'margin-top:8px;';
                    opt.innerHTML = `<h4>${die.name}</h4><p>Offer to the Ferryman</p>`;
                    opt.onclick = () => {
                        // Mark this die with a crossed segment (weighted to high numbers)
                        // Weights: 11-14 = 1x chance, 15-17 = 2x, 18-19 = 3x
                        const weightedPool = [];
                        for (let i = 11; i <= 14; i++) weightedPool.push(i);
                        for (let i = 15; i <= 17; i++) { weightedPool.push(i); weightedPool.push(i); }
                        for (let i = 18; i <= 19; i++) { weightedPool.push(i); weightedPool.push(i); weightedPool.push(i); }

                        const crossedFace = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                        die.crossedSegments.push(crossedFace);

                        gameState.ferrymanChoices[player.id] = `${die.name} (${crossedFace} crossed)`;
                        log(`${player.name}'s ${die.name}: face ${crossedFace} marked!`, 'doom');

                        // Check if all players have chosen
                        if (Object.keys(gameState.ferrymanChoices).length >= gameState.players.length) {
                            modal.classList.remove('show');
                            delete gameState.ferrymanChoices;
                            log('The Ferryman grins. "Safe passage... for now."', 'info');
                            completeEncounter();
                        } else {
                            handleFerrymanMark(); // Re-render
                        }
                    };
                    playerDiv.appendChild(opt);
                });

                options.appendChild(playerDiv);
            });

            modal.classList.add('show');
        }

        function handleDrunkBlessing() {
            // Drunk Priest uses weighted outcomes: 7/15 good, 4/15 neutral, 4/15 bad
            const outcome = getNeutralOutcome();

            if (outcome === 'good') {
                // Good: More HOPE than any downside
                const hopeGain = Math.floor(Math.random() * 2) + 3; // 3-4 HOPE
                addHope(hopeGain);
                log(`The blessing lands true! +${hopeGain} HOPE! The drunk priest winks.`, 'hope');

                // Also add a HOPE segment to a random die
                const randomPlayer = gameState.players[Math.floor(Math.random() * gameState.players.length)];
                const dieTypes = ['physical', 'verbal', 'preventative'];
                const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
                const die = randomPlayer.dice[randomDieType];
                const segmentToHope = Math.floor(Math.random() * 10) + 6; // 6-15 (useful range)
                die.hopeSegments = die.hopeSegments || [];
                die.hopeSegments.push(segmentToHope);
                log(`${die.name} blessed! Rolling ${segmentToHope} grants +1 HOPE`, 'hope');

            } else if (outcome === 'neutral') {
                // Neutral: HOPE equals DOOM, wash
                const amount = Math.floor(Math.random() * 2) + 2; // 2-3
                addHope(amount);
                addDoom(amount, 'Blessing side effect');
                log(`Mixed blessing... +${amount} HOPE but also +${amount} DOOM. It balances out.`, 'info');

            } else {
                // Bad: More DOOM than HOPE
                const hopeGain = 1;
                const doomGain = Math.floor(Math.random() * 2) + 2; // 2-3 DOOM
                addHope(hopeGain);
                addDoom(doomGain, 'Sloppy blessing went wrong');
                log(`The blessing goes awry! +${hopeGain} HOPE but +${doomGain} DOOM...`, 'fail');
            }

            completeEncounter();
        }

        function handleCultistDrink() {
            // Cultist drink uses weighted outcomes: 7/15 good, 4/15 neutral, 4/15 bad
            const outcome = getNeutralOutcome();

            const randomPlayer = gameState.players[Math.floor(Math.random() * gameState.players.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
            const die = randomPlayer.dice[randomDieType];

            if (outcome === 'good') {
                // Good: Beneficial swap + nice upgrade
                createRandomSwap(randomPlayer, die);

                // Upgrade: +5 to lowest face
                const minVal = Math.min(...die.faces);
                const minIdx = die.faces.indexOf(minVal);
                die.faces[minIdx] += 5;

                log(`The cosmic bond empowers you! ${die.name} lowest face ${minVal} â†’ ${minVal + 5}`, 'crit');
                log('Your fates are intertwined with your allies!', 'success');

            } else if (outcome === 'neutral') {
                // Neutral: Just the swap, no bonus or penalty
                createRandomSwap(randomPlayer, die);
                log(`The drink takes hold... ${randomPlayer.name}'s ${die.name} is now linked to an ally.`, 'info');

            } else {
                // Bad: Forced unfavorable swap + minor DOOM
                // Create a swap that links a HIGH number to ally's roll (potentially losing good rolls)
                const highFace = Math.floor(Math.random() * 5) + 15; // 15-19
                const allyIdx = (gameState.players.indexOf(randomPlayer) + 1) % 3;
                const ally = gameState.players[allyIdx];
                const allyDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];

                die.swaps = die.swaps || [];
                die.swaps.push({
                    triggerValue: highFace,
                    targetPlayer: allyIdx,
                    targetDieType: allyDieType
                });

                addDoom(1, 'Cosmic backlash');
                log(`The drink sours... Rolling ${highFace} on ${die.name} now triggers ${ally.name}'s ${ally.dice[allyDieType].name}!`, 'fail');
                log('+1 DOOM from cosmic backlash.', 'fail');
            }

            renderDiceTray();
            completeEncounter();
        }

        // ==================== NEW ENCOUNTER FUNCTIONS ====================

        // Exotic Dice definitions for The Trapper
        const EXOTIC_DICE = [
            { id: 'd6', name: 'The d6', description: 'Faces: 1, 2, 6, 12, 19, 20',
              faces: [1,1,1,2,2,2,6,6,6,6,12,12,12,12,19,19,19,20,20,20], power: 1 },
            { id: 'lucky7', name: 'Lucky 7s', description: 'All 7s become 17s, 17s become 20s',
              faces: [1,2,3,4,5,6,17,8,9,10,11,12,13,14,15,16,20,18,19,20], power: 2 },
            { id: 'coin', name: 'The Coin Flip', description: '10 faces of 20, 10 faces of 1',
              faces: [1,1,1,1,1,1,1,1,1,1,20,20,20,20,20,20,20,20,20,20], power: 3 },
            { id: '6996', name: 'The 6996', description: 'All 6s and 9s are flipped',
              faces: [1,2,3,4,5,9,7,8,6,10,11,12,13,14,15,9,17,18,6,20], power: 7 },
            { id: 'cursed', name: 'The Cursed', description: 'One 1 becomes 20, one 20 becomes 1',
              faces: [20,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,1], power: 5 },
            { id: 'weighted', name: 'The Weighted', description: 'Only 8-15 (consistent but capped)',
              faces: [8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,10,11,12,13], power: 6 },
            { id: 'shifter', name: 'The Shifter', description: 'Odd +3, Even -3',
              faces: [4,-1,6,1,8,3,10,5,12,7,14,9,16,11,18,13,20,15,22,17], power: 8 },
            { id: 'wildcard', name: 'The Wild Card', description: 'Every roll triggers random ally die',
              faces: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], isWildcard: true, power: 4 }
        ];

        function showExoticDiceTrade() {
            // Pick 3 random exotic dice to offer
            const shuffled = [...EXOTIC_DICE].sort(() => Math.random() - 0.5);
            const offered = shuffled.slice(0, 3).sort((a, b) => a.power - b.power);

            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Trapper\'s Exotic Dice';
            document.getElementById('upgradeDescription').innerHTML = `
                <p>Trade one of your dice for an exotic one. The more powerful the exotic die, the stronger YOUR die must be to trade.</p>
                <p style="color:#ffd700; margin-top:10px;">Best die = Most powerful exotic | Middle die = Medium exotic | Worst die = Weak exotic</p>
            `;

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            // Show the three exotic dice available
            const diceRow = document.createElement('div');
            diceRow.style.cssText = 'display:flex; gap:15px; margin:20px 0; justify-content:center; flex-wrap:wrap;';

            offered.forEach((exotic, idx) => {
                const tier = idx === 0 ? 'WEAK (trade worst die)' : idx === 1 ? 'MEDIUM (trade middle die)' : 'POWERFUL (trade best die)';
                const tierColor = idx === 0 ? '#888' : idx === 1 ? '#88ccff' : '#ffd700';

                const card = document.createElement('div');
                card.style.cssText = `padding:15px; background:rgba(255,255,255,0.08); border-radius:10px; text-align:center; min-width:150px; border:2px solid ${tierColor};`;
                card.innerHTML = `
                    <h4 style="color:${tierColor};">${exotic.name}</h4>
                    <p style="font-size:0.9em; color:#aaa;">${exotic.description}</p>
                    <p style="font-size:0.8em; color:${tierColor}; margin-top:8px;">${tier}</p>
                `;
                diceRow.appendChild(card);
            });
            options.appendChild(diceRow);

            // Now show which player's die they want to trade
            gameState.players.forEach((player, pIdx) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'margin-top:15px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;';
                playerDiv.innerHTML = `<strong style="color:#88ccff;">${player.name}'s Dice:</strong>`;

                // Rank player's dice by power (based on average face value)
                const diceRanked = Object.entries(player.dice).map(([type, die]) => ({
                    type, die,
                    avgValue: die.faces.reduce((a,b) => a+b, 0) / die.faces.length
                })).sort((a, b) => a.avgValue - b.avgValue); // worst to best

                const btnRow = document.createElement('div');
                btnRow.style.cssText = 'display:flex; gap:10px; margin-top:8px; flex-wrap:wrap;';

                diceRanked.forEach((ranked, rankIdx) => {
                    const exoticToGet = offered[rankIdx]; // worst die = weak exotic, etc.
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.style.cssText = 'flex:1; min-width:120px;';
                    btn.innerHTML = `Trade ${ranked.die.name}<br><small>â†’ ${exoticToGet.name}</small>`;
                    btn.onclick = () => {
                        // Replace the die's faces with the exotic die's faces
                        ranked.die.faces = [...exoticToGet.faces];
                        if (exoticToGet.isWildcard) {
                            // Wild Card: every roll triggers random ally
                            for (let i = 1; i <= 20; i++) {
                                ranked.die.swaps.push({
                                    faceValue: i,
                                    targetPlayer: (pIdx + 1 + Math.floor(Math.random() * 2)) % 3,
                                    targetDieType: ['physical','verbal','preventative'][Math.floor(Math.random() * 3)]
                                });
                            }
                        }
                        log(`${player.name} trades ${ranked.die.name} for ${exoticToGet.name}!`, 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    btnRow.appendChild(btn);
                });

                playerDiv.appendChild(btnRow);
                options.appendChild(playerDiv);
            });

            // Add leave button
            const leaveBtn = document.createElement('button');
            leaveBtn.className = 'option-btn';
            leaveBtn.style.marginTop = '20px';
            leaveBtn.textContent = 'Leave without trading';
            leaveBtn.onclick = () => {
                modal.classList.remove('show');
                completeEncounter();
            };
            options.appendChild(leaveBtn);

            modal.classList.add('show');
        }

        function showBlessSegmentModal() {
            // Bless a specific segment to grant +1 HOPE when rolled
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'Bless a Segment';
            document.getElementById('upgradeDescription').textContent = 'Choose a die segment. When that number is rolled, you gain +1 HOPE!';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Add HOPE to a segment</p>
                    `;
                    opt.onclick = () => showSegmentPicker(player, die, modal);
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showSegmentPicker(player, die, modal) {
            document.getElementById('upgradeDescription').textContent = `Choose a number (6-15) on ${player.name}'s ${die.name} to bless:`;
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            const numRow = document.createElement('div');
            numRow.style.cssText = 'display:flex; gap:8px; flex-wrap:wrap; justify-content:center;';

            for (let i = 6; i <= 15; i++) {
                const btn = document.createElement('button');
                btn.className = 'number-btn';
                btn.textContent = i;
                btn.onclick = () => {
                    die.hopeSegments = die.hopeSegments || [];
                    die.hopeSegments.push(i);
                    log(`${die.name} blessed! Rolling ${i} grants +1 HOPE`, 'hope');
                    modal.classList.remove('show');
                    completeEncounter();
                };
                numRow.appendChild(btn);
            }
            options.appendChild(numRow);
        }

        function showDoubleLinkModal() {
            // Link one die to BOTH allies
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'Double Link';
            document.getElementById('upgradeDescription').textContent = 'Choose a die to link to BOTH allies! Pick a low number for each ally.';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Create double link</p>
                    `;
                    opt.onclick = () => {
                        // Link to both other players with random low numbers
                        const otherPlayers = gameState.players.filter((_, i) => i !== pIdx);
                        const lowNumbers = [2, 3, 4, 5];

                        otherPlayers.forEach((ally, i) => {
                            const faceValue = lowNumbers[i * 2] || lowNumbers[0];
                            const allyDieType = ['physical', 'verbal', 'preventative'][Math.floor(Math.random() * 3)];
                            die.swaps.push({
                                faceValue: faceValue,
                                targetPlayer: gameState.players.indexOf(ally),
                                targetDieType: allyDieType
                            });
                            log(`${die.name}: ${faceValue} â†’ ${ally.name}'s ${ally.dice[allyDieType].name}`, 'swap');
                        });

                        log('Double link created! Your fates are deeply intertwined!', 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showGambleRangeChoice() {
            // Craps-style: choose IN or OUT of range before rolling
            const rangeStart = Math.floor(Math.random() * 8) + 5; // 5-12
            const rangeEnd = Math.min(rangeStart + Math.floor(Math.random() * 5) + 3, 18); // +3 to +7

            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Range Game';

            const rangeSize = rangeEnd - rangeStart + 1;
            const inRangeChance = Math.round((rangeSize / 20) * 100);
            const outRangeChance = 100 - inRangeChance;

            document.getElementById('upgradeDescription').innerHTML = `
                <div style="padding:15px; background:rgba(255,215,0,0.15); border-radius:10px; border-left:4px solid #ffd700; margin:10px 0;">
                    <h3 style="color:#ffd700;">Range: ${rangeStart} - ${rangeEnd}</h3>
                    <p style="margin-top:10px;"><strong>IN RANGE</strong> (${inRangeChance}% chance): <span style="color:#4ade80;">+5 to segment of your choice!</span></p>
                    <p><strong>OUT OF RANGE</strong> (${outRangeChance}% chance): <span style="color:#88ccff;">+3 to random segment</span></p>
                </div>
                <p>Choose your bet, then roll any die!</p>
            `;

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            const betIn = document.createElement('button');
            betIn.className = 'option-btn';
            betIn.innerHTML = `<strong>Bet IN RANGE</strong><br>Win big if ${rangeStart}-${rangeEnd}`;
            betIn.onclick = () => {
                gameState.canRoll = true;
                gameState.encounterState = {
                    type: 'gamble',
                    rangeMin: rangeStart,
                    rangeMax: rangeEnd,
                    bet: 'in',
                    inRangeReward: 5,
                    outRangeReward: 3
                };
                modal.classList.remove('show');
                document.getElementById('encounterDescription').innerHTML = `
                    <p>You bet <strong>IN RANGE (${rangeStart}-${rangeEnd})</strong>!</p>
                    <p style="margin-top:15px; color:#88ccff;">Roll any die!</p>
                `;
                document.getElementById('encounterOptions').innerHTML = '';
                renderDiceTray();
            };
            options.appendChild(betIn);

            const betOut = document.createElement('button');
            betOut.className = 'option-btn';
            betOut.innerHTML = `<strong>Bet OUT OF RANGE</strong><br>Win if 1-${rangeStart-1} or ${rangeEnd+1}-20`;
            betOut.onclick = () => {
                gameState.canRoll = true;
                gameState.encounterState = {
                    type: 'gamble',
                    rangeMin: rangeStart,
                    rangeMax: rangeEnd,
                    bet: 'out',
                    inRangeReward: 3, // worse reward when betting out
                    outRangeReward: 5 // better reward when betting out
                };
                modal.classList.remove('show');
                document.getElementById('encounterDescription').innerHTML = `
                    <p>You bet <strong>OUT OF RANGE</strong> (1-${rangeStart-1} or ${rangeEnd+1}-20)!</p>
                    <p style="margin-top:15px; color:#88ccff;">Roll any die!</p>
                `;
                document.getElementById('encounterOptions').innerHTML = '';
                renderDiceTray();
            };
            options.appendChild(betOut);

            modal.classList.add('show');
        }

        // ==================== UTILITIES ====================
        function addGold(amount) {
            gameState.gold += amount;
            updateDoomHopeDisplay();
            log(`+${amount} Gold!`, 'crit');
        }

        function spendGold(amount) {
            if (gameState.gold >= amount) {
                gameState.gold -= amount;
                updateDoomHopeDisplay();
                return true;
            }
            return false;
        }

        function log(message, type = '') {
            const logDiv = document.getElementById('gameLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.getElementById('pauseModal').classList.contains('show')) {
                    closePauseMenu();
                } else if (document.getElementById('upgradeModal').classList.contains('show')) {
                    document.getElementById('upgradeModal').classList.remove('show');
                } else if (!document.getElementById('gameScreen').classList.contains('hidden')) {
                    showPauseMenu();
                }
            }
        });
    </script>
</body>
</html>
