<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Dice Game</title>
    <!-- Favicon - D20 Die -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><polygon points='50,5 95,30 95,70 50,95 5,70 5,30' fill='%231a1a2e' stroke='%23ffd700' stroke-width='3'/><polygon points='50,5 95,30 50,50' fill='%234a4a6a'/><polygon points='5,30 50,5 50,50' fill='%233a3a5a'/><polygon points='50,50 95,30 95,70 50,95' fill='%232a2a4a'/><polygon points='50,50 5,30 5,70 50,95' fill='%23353555'/><text x='50' y='58' text-anchor='middle' fill='%23ffd700' font-family='Arial' font-size='24' font-weight='bold'>20</text></svg>">
    <!-- Google Fonts for player distinction -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Rajdhani:wght@700&family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Action Type Colors */
            --physical-primary: #c45c26;
            --physical-secondary: #8b4513;
            --physical-glow: rgba(196, 92, 38, 0.6);

            --verbal-primary: #2980b9;
            --verbal-secondary: #1a5276;
            --verbal-glow: rgba(41, 128, 185, 0.6);

            --preventative-primary: #8e44ad;
            --preventative-secondary: #5b2c6f;
            --preventative-glow: rgba(142, 68, 173, 0.6);

            /* DOOM/HOPE Colors */
            --doom-color: #8b0000;
            --hope-color: #4ade80;

            /* Player Fonts */
            --font-player1: 'Cinzel', serif;
            --font-player2: 'Rajdhani', sans-serif;
            --font-player3: 'Permanent Marker', cursive;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #eee;
            overflow-x: hidden;
        }

        /* Screen Transitions */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
            z-index: 100;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        /* ==================== TITLE SCREEN ==================== */
        .title-screen {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
            z-index: 1000;
        }

        .title-logo {
            text-align: center;
            margin-bottom: 60px;
        }

        .title-dice {
            font-size: 80px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .title-logo h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 0.1em;
            margin-top: 20px;
        }

        .title-logo .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-top: 10px;
            font-style: italic;
        }

        .title-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px;
        }

        .menu-btn {
            padding: 18px 30px;
            font-size: 1.2rem;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 2px solid #4a4a6a;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .menu-btn:hover {
            background: linear-gradient(135deg, #3a3a5a, #2a2a4a);
            border-color: #ffd700;
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.2);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            border-color: #ffd700;
        }

        .menu-btn.primary:hover {
            background: linear-gradient(135deg, #ffee00, #ffcc00);
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4);
        }

        .version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #555;
            font-size: 0.9rem;
        }

        /* ==================== HOW TO PLAY SCREEN ==================== */
        .howto-screen {
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            overflow-y: auto;
        }

        .howto-content {
            max-width: 800px;
            text-align: left;
        }

        .howto-content h1 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-align: center;
        }

        .howto-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid #ffd700;
        }

        .howto-section h2 {
            color: #88ccff;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .howto-section p {
            line-height: 1.8;
            color: #ccc;
        }

        .dice-type-preview {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .type-preview {
            text-align: center;
            padding: 15px 25px;
            border-radius: 10px;
        }

        .type-preview.physical { background: var(--physical-secondary); }
        .type-preview.verbal { background: var(--verbal-secondary); }
        .type-preview.preventative { background: var(--preventative-secondary); }

        .type-preview h4 { margin-bottom: 8px; }
        .type-preview ul { list-style: none; text-align: left; }

        .back-btn {
            margin-top: 30px;
            display: block;
            width: 200px;
            margin-left: auto;
            margin-right: auto;
        }

        /* ==================== SETUP SCREEN ==================== */
        .setup-screen {
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            overflow-y: auto;
        }

        .setup-screen h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .setup-screen .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .setup-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            max-width: 900px;
            width: 100%;
        }

        .player-setup {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 4px solid #555;
        }

        .player-setup.player-1 { border-left-color: #ffd700; }
        .player-setup.player-2 { border-left-color: #88ccff; }
        .player-setup.player-3 { border-left-color: #ff88cc; }

        .player-setup h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-setup.player-1 h3 { font-family: var(--font-player1); }
        .player-setup.player-2 h3 { font-family: var(--font-player2); }
        .player-setup.player-3 h3 { font-family: var(--font-player3); }

        .player-name-input {
            padding: 8px 12px;
            border: 2px solid #4a4a6a;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border-radius: 5px;
            font-size: 1rem;
            width: 150px;
        }

        .player-setup.player-1 .player-name-input { font-family: var(--font-player1); }
        .player-setup.player-2 .player-name-input { font-family: var(--font-player2); }
        .player-setup.player-3 .player-name-input { font-family: var(--font-player3); }

        .dice-selection {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .dice-category {
            flex: 1;
            min-width: 150px;
        }

        .dice-category h4 {
            margin-bottom: 10px;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }

        .dice-category h4.physical { background: var(--physical-secondary); }
        .dice-category h4.verbal { background: var(--verbal-secondary); }
        .dice-category h4.preventative { background: var(--preventative-secondary); }

        .dice-option {
            display: block;
            padding: 10px 15px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .dice-option input {
            margin-right: 10px;
        }

        .dice-option.physical { background: rgba(196, 92, 38, 0.2); }
        .dice-option.verbal { background: rgba(41, 128, 185, 0.2); }
        .dice-option.preventative { background: rgba(142, 68, 173, 0.2); }

        .dice-option:hover {
            transform: translateX(5px);
        }

        .dice-option.physical:hover { border-color: var(--physical-primary); }
        .dice-option.verbal:hover { border-color: var(--verbal-primary); }
        .dice-option.preventative:hover { border-color: var(--preventative-primary); }

        .start-btn {
            display: block;
            width: 100%;
            padding: 20px;
            font-size: 1.3rem;
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .start-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
        }

        /* ==================== MAIN GAME ==================== */
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .game-screen {
            z-index: 50;
        }

        .game-screen.hidden {
            display: none;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4a4a6a;
        }

        .header h1 {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            color: #ffd700;
        }

        .floor-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .gold {
            color: #ffd700;
            font-weight: bold;
        }

        /* DOOM/HOPE Display */
        .doom-hope-display {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .doom-meter, .hope-meter {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .doom-meter {
            background: rgba(139, 0, 0, 0.3);
            border: 2px solid var(--doom-color);
            color: #ff6b6b;
        }

        .hope-meter {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid var(--hope-color);
            color: var(--hope-color);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4a4a6a;
            color: #aaa;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        /* Main game area */
        .main-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Map Panel */
        .map-panel {
            width: 280px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 2px solid #4a4a6a;
            padding: 15px;
            overflow-y: auto;
        }

        .map-panel h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #88ccff;
            font-family: 'Cinzel', serif;
        }

        .map-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .map-row {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .map-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid #444;
        }

        .map-node.current {
            border-color: #ffd700;
            box-shadow: 0 0 20px #ffd700;
            animation: pulse 1.5s infinite;
        }

        .map-node.completed {
            opacity: 0.4;
            border-color: #333;
        }

        .map-node.locked {
            opacity: 0.25;
            cursor: not-allowed;
        }

        .map-node.available {
            border-color: #88ff88;
            cursor: pointer;
        }

        .map-node.available:hover {
            transform: scale(1.15);
            box-shadow: 0 0 15px #88ff88;
        }

        .map-node.good { background: linear-gradient(135deg, #2d5a27, #1d4a17); }
        .map-node.bad { background: linear-gradient(135deg, #5a2727, #4a1717); }
        .map-node.neutral { background: linear-gradient(135deg, #5a5a27, #4a4a17); }
        .map-node.boss { background: linear-gradient(135deg, #5a2757, #4a1747); }
        .map-node.start { background: linear-gradient(135deg, #275a5a, #174a4a); }

        .map-path {
            width: 3px;
            height: 15px;
            background: linear-gradient(to bottom, #555, #333);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px #ffd700; }
            50% { box-shadow: 0 0 30px #ffd700; }
        }

        /* Encounter Panel */
        .encounter-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .encounter-content {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .encounter-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .encounter-header h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .encounter-type {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .encounter-type.good { background: #2d5a27; }
        .encounter-type.bad { background: #5a2727; }
        .encounter-type.neutral { background: #5a5a27; }
        .encounter-type.boss { background: #5a2757; }

        .encounter-description {
            flex: 1;
            padding: 15px;
            line-height: 1.7;
            font-size: 1.05rem;
        }

        .encounter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
        }

        .option-btn {
            padding: 15px 25px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            background: #3a3a5a;
            color: #fff;
        }

        .option-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .option-btn.physical {
            background: var(--physical-secondary);
            border-color: var(--physical-primary);
        }
        .option-btn.physical:hover { box-shadow: 0 8px 25px var(--physical-glow); }

        .option-btn.verbal {
            background: var(--verbal-secondary);
            border-color: var(--verbal-primary);
        }
        .option-btn.verbal:hover { box-shadow: 0 8px 25px var(--verbal-glow); }

        .option-btn.preventative {
            background: var(--preventative-secondary);
            border-color: var(--preventative-primary);
        }
        .option-btn.preventative:hover { box-shadow: 0 8px 25px var(--preventative-glow); }

        .option-btn.swap {
            background: linear-gradient(135deg, #4a3a6a, #3a2a5a);
            border-color: #8855cc;
        }
        .option-btn.swap:hover { box-shadow: 0 8px 25px rgba(136, 85, 204, 0.5); }

        .option-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Players sidebar */
        .players-panel {
            width: 220px;
            background: rgba(0, 0, 0, 0.4);
            border-right: 2px solid #4a4a6a;
            padding: 15px;
            overflow-y: auto;
        }

        .players-panel > h3 {
            font-family: 'Cinzel', serif;
            margin-bottom: 15px;
            color: #88ccff;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            border-left: 4px solid #555;
        }

        .player-card.player-1 { border-left-color: #ffd700; }
        .player-card.player-2 { border-left-color: #88ccff; }
        .player-card.player-3 { border-left-color: #ff88cc; }

        .player-card h3 {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
        }

        .player-card.player-1 h3 { font-family: var(--font-player1); }
        .player-card.player-2 h3 { font-family: var(--font-player2); }
        .player-card.player-3 h3 { font-family: var(--font-player3); }

        .player-hp {
            font-family: 'Segoe UI', system-ui, sans-serif !important;
        }

        .player-dice-mini {
            display: flex;
            gap: 5px;
        }

        .mini-die {
            width: 35px;
            height: 35px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            text-align: center;
            font-weight: bold;
            position: relative;
        }

        .mini-die.physical { background: var(--physical-secondary); }
        .mini-die.verbal { background: var(--verbal-secondary); }
        .mini-die.preventative { background: var(--preventative-secondary); }

        .mini-die .swap-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 14px;
            height: 14px;
            background: #8855cc;
            border-radius: 50%;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ==================== DICE TRAY ==================== */
        .dice-tray {
            background: linear-gradient(to bottom, #252535, #151525);
            border-top: 3px solid #4a4a6a;
            padding: 15px 20px;
            min-height: 160px;
        }

        .dice-tray-header {
            text-align: center;
            margin-bottom: 12px;
            color: #88ccff;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
        }

        .dice-grid {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .player-dice-group {
            text-align: center;
        }

        .player-dice-group h4 {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #888;
        }

        .player-dice-group.player-1 h4 {
            font-family: var(--font-player1);
            color: #ffd700;
        }
        .player-dice-group.player-2 h4 {
            font-family: var(--font-player2);
            color: #88ccff;
        }
        .player-dice-group.player-3 h4 {
            font-family: var(--font-player3);
            color: #ff88cc;
        }

        .dice-row {
            display: flex;
            gap: 10px;
        }

        .die {
            width: 75px;
            height: 75px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            position: relative;
        }

        /* Physical dice */
        .die.physical {
            background: linear-gradient(145deg, var(--physical-primary), var(--physical-secondary));
            border-color: var(--physical-primary);
        }
        .die.physical:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--physical-glow);
        }

        /* Verbal dice */
        .die.verbal {
            background: linear-gradient(145deg, var(--verbal-primary), var(--verbal-secondary));
            border-color: var(--verbal-primary);
        }
        .die.verbal:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--verbal-glow);
        }

        /* Preventative dice */
        .die.preventative {
            background: linear-gradient(145deg, var(--preventative-primary), var(--preventative-secondary));
            border-color: var(--preventative-primary);
        }
        .die.preventative:hover:not(.disabled) {
            box-shadow: 0 8px 30px var(--preventative-glow);
        }

        .die:hover:not(.disabled) {
            transform: translateY(-8px) scale(1.05);
        }

        .die.selected {
            border-color: #ffd700 !important;
            box-shadow: 0 0 25px #ffd700 !important;
        }

        .die.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        .die.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .die.has-swap {
            border-style: dashed;
        }

        .die .swap-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #8855cc;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Player-specific fonts on dice */
        .die.player-1 .die-name { font-family: var(--font-player1); }
        .die.player-2 .die-name { font-family: var(--font-player2); }
        .die.player-3 .die-name { font-family: var(--font-player3); }

        .die-name {
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .die-value {
            font-size: 1.6rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .die.rolling {
            animation: diceRoll 0.15s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(10deg) scale(1.05); }
            50% { transform: rotate(0deg) scale(1); }
            75% { transform: rotate(-10deg) scale(1.05); }
            100% { transform: rotate(0deg) scale(1); }
        }

        /* ==================== MODALS ==================== */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Roll Result */
        .roll-result {
            text-align: center;
        }

        .roll-result-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid #ffd700;
        }

        .roll-result h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.4rem;
            margin-bottom: 10px;
            color: #aaa;
        }

        .roll-result .result-value {
            font-size: 6rem;
            font-weight: bold;
            margin: 20px 0;
            font-family: 'Cinzel', serif;
        }

        .roll-result .result-value.success { color: #4ade80; }
        .roll-result .result-value.fail { color: #f87171; }
        .roll-result .result-value.crit {
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            animation: critGlow 0.5s infinite alternate;
        }

        .roll-result .swap-triggered {
            background: rgba(136, 85, 204, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px 0;
            color: #cc99ff;
            font-style: italic;
        }

        @keyframes critGlow {
            from { text-shadow: 0 0 20px #ffd700; }
            to { text-shadow: 0 0 40px #ffd700, 0 0 60px #ffaa00; }
        }

        .roll-result .outcome {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: #ccc;
        }

        .roll-result .doom-change {
            padding: 8px 16px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .roll-result .doom-change.doom-up {
            background: rgba(139, 0, 0, 0.3);
            color: #ff6b6b;
        }

        .roll-result .doom-change.doom-down {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .roll-result button {
            padding: 12px 40px;
            font-size: 1rem;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            background: #4a4a6a;
            border: 2px solid #6a6a8a;
            color: white;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .roll-result button:hover {
            background: #5a5a7a;
            transform: translateY(-2px);
        }

        /* Upgrade Modal */
        .upgrade-modal .modal-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 30px;
            border-radius: 15px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            border: 2px solid #4a4a6a;
        }

        .upgrade-modal h2 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .upgrade-modal p {
            color: #aaa;
            margin-bottom: 20px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .upgrade-option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            border: 2px solid transparent;
        }

        .upgrade-option:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
            border-color: #ffd700;
        }

        .upgrade-option.swap-option {
            border-color: #8855cc;
            background: rgba(136, 85, 204, 0.15);
        }

        .upgrade-option.swap-option:hover {
            border-color: #aa77ee;
            background: rgba(136, 85, 204, 0.25);
        }

        .upgrade-option h4 {
            color: #88ccff;
            margin-bottom: 5px;
        }

        .upgrade-option p {
            color: #888;
            font-size: 0.9rem;
            margin: 0;
        }

        /* Pause Modal */
        .pause-modal .modal-content {
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #4a4a6a;
            min-width: 300px;
        }

        .pause-modal h2 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Game Log */
        .game-log {
            position: fixed;
            bottom: 180px;
            left: 15px;
            width: 280px;
            max-height: 180px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.8rem;
            z-index: 100;
            border: 1px solid #333;
        }

        .game-log h4 {
            color: #666;
            margin-bottom: 8px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .log-entry {
            padding: 4px 8px;
            border-radius: 3px;
            margin-bottom: 3px;
            color: #999;
        }

        .log-entry.success { color: #4ade80; background: rgba(74, 222, 128, 0.1); }
        .log-entry.fail { color: #f87171; background: rgba(248, 113, 113, 0.1); }
        .log-entry.crit { color: #ffd700; background: rgba(255, 215, 0, 0.1); }
        .log-entry.info { color: #88ccff; background: rgba(136, 204, 255, 0.1); }
        .log-entry.doom { color: #ff6b6b; background: rgba(139, 0, 0, 0.2); }
        .log-entry.hope { color: #4ade80; background: rgba(74, 222, 128, 0.15); }
        .log-entry.swap { color: #cc99ff; background: rgba(136, 85, 204, 0.15); }

        /* ==================== END SCREENS ==================== */
        .end-screen {
            z-index: 3000;
        }

        .end-content {
            text-align: center;
        }

        .end-screen h1 {
            font-family: 'Cinzel', serif;
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .end-screen.victory h1 {
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }
        .end-screen.defeat h1 {
            color: #f87171;
        }

        .end-screen p {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #aaa;
        }

        .end-screen .end-buttons {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
    </style>
</head>
<body>
    <!-- ==================== TITLE SCREEN ==================== -->
    <div class="screen title-screen" id="titleScreen">
        <div class="title-logo">
            <div class="title-dice">ðŸŽ²</div>
            <h1>UNTITLED DICE GAME</h1>
            <p class="subtitle">A Collaborative TTRPG Adventure</p>
        </div>
        <div class="title-menu">
            <button class="menu-btn primary" onclick="showScreen('setupScreen')">New Game</button>
            <button class="menu-btn" onclick="showScreen('howtoScreen')">How to Play</button>
            <button class="menu-btn" onclick="showScreen('settingsScreen')">Settings</button>
        </div>
        <div class="version">v0.2.0 - Dice Swapping Update</div>
    </div>

    <!-- ==================== HOW TO PLAY SCREEN ==================== -->
    <div class="screen howto-screen hidden" id="howtoScreen">
        <div class="howto-content">
            <h1>How to Play</h1>

            <div class="howto-section">
                <h2>Objective</h2>
                <p>Work together with your party of 3 heroes to defeat the Dirty Innkeeper! Navigate through encounters, upgrade your dice, and make strategic decisions to survive.</p>
            </div>

            <div class="howto-section">
                <h2>Your Dice</h2>
                <p>Each player has 3 dice - one from each action category. Click a die in the tray to roll it during encounters. Each die starts as a standard d20, but can be upgraded!</p>
                <div class="dice-type-preview">
                    <div class="type-preview physical">
                        <h4>Physical</h4>
                        <ul>
                            <li>Slash</li>
                            <li>Stab</li>
                            <li>Bonk</li>
                        </ul>
                    </div>
                    <div class="type-preview verbal">
                        <h4>Verbal</h4>
                        <ul>
                            <li>Threaten</li>
                            <li>Deceive</li>
                            <li>Persuade</li>
                        </ul>
                    </div>
                    <div class="type-preview preventative">
                        <h4>Preventative</h4>
                        <ul>
                            <li>Bribe</li>
                            <li>Hide</li>
                            <li>Grapple</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="howto-section">
                <h2>Dice Swapping</h2>
                <p>The unique mechanic! You can link segments of your dice to teammates' dice. When you roll a swapped number, your teammate's die activates instead - for better or worse!</p>
            </div>

            <div class="howto-section">
                <h2>DOOM & HOPE</h2>
                <p><strong>DOOM</strong> accumulates when you fail or get hit. High DOOM makes your dice weaker. Roll a Nat 1 with high DOOM and your journey ends!<br><br>
                <strong>HOPE</strong> offsets DOOM. Earn it through certain encounters and upgrades.</p>
            </div>

            <div class="howto-section">
                <h2>The Map</h2>
                <p>Navigate through branching paths. Green borders = available paths. Different icons show encounter types:</p>
                <ul style="margin-top:10px; margin-left:20px; line-height:2;">
                    <li><span style="color:#4ade80;">Good</span> - Safe encounters, upgrades, shops</li>
                    <li><span style="color:#f87171;">Bad</span> - Combat encounters, risk vs reward</li>
                    <li><span style="color:#ffd700;">Neutral</span> - Could go either way...</li>
                    <li><span style="color:#c084fc;">Boss</span> - The floor's final challenge</li>
                </ul>
            </div>

            <button class="menu-btn back-btn" onclick="showScreen('titleScreen')">Back to Menu</button>
        </div>
    </div>

    <!-- ==================== SETTINGS SCREEN ==================== -->
    <div class="screen howto-screen hidden" id="settingsScreen">
        <div class="howto-content" style="max-width:500px;">
            <h1>Settings</h1>

            <div class="howto-section">
                <h2>Sound</h2>
                <p style="color:#666;">(Coming soon - sound effects and music)</p>
            </div>

            <div class="howto-section">
                <h2>Save Data</h2>
                <p style="color:#666;">(Coming soon - save slots)</p>
            </div>

            <button class="menu-btn back-btn" onclick="showScreen('titleScreen')">Back to Menu</button>
        </div>
    </div>

    <!-- ==================== SETUP SCREEN ==================== -->
    <div class="screen setup-screen hidden" id="setupScreen">
        <h1>Party Setup</h1>
        <p class="subtitle">Floor 1: The Dirty Innkeeper</p>
        <div class="setup-content">
            <div class="player-setup player-1">
                <h3>
                    <span>Player 1:</span>
                    <input type="text" class="player-name-input" id="p1name" value="Hero" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="slash" checked> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="stab"> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p1physical" value="bonk"> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="threaten" checked> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="deceive"> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p1verbal" value="persuade"> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="bribe" checked> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="hide"> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p1preventative" value="grapple"> Grapple</label>
                    </div>
                </div>
            </div>

            <div class="player-setup player-2">
                <h3>
                    <span>Player 2:</span>
                    <input type="text" class="player-name-input" id="p2name" value="Rogue" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="slash"> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="stab" checked> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p2physical" value="bonk"> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="threaten"> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="deceive" checked> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p2verbal" value="persuade"> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="bribe"> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="hide" checked> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p2preventative" value="grapple"> Grapple</label>
                    </div>
                </div>
            </div>

            <div class="player-setup player-3">
                <h3>
                    <span>Player 3:</span>
                    <input type="text" class="player-name-input" id="p3name" value="Bard" maxlength="12">
                </h3>
                <div class="dice-selection">
                    <div class="dice-category">
                        <h4 class="physical">Physical</h4>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="slash"> Slash</label>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="stab"> Stab</label>
                        <label class="dice-option physical"><input type="radio" name="p3physical" value="bonk" checked> Bonk</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="verbal">Verbal</h4>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="threaten"> Threaten</label>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="deceive"> Deceive</label>
                        <label class="dice-option verbal"><input type="radio" name="p3verbal" value="persuade" checked> Persuade</label>
                    </div>
                    <div class="dice-category">
                        <h4 class="preventative">Preventative</h4>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="bribe"> Bribe</label>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="hide"> Hide</label>
                        <label class="dice-option preventative"><input type="radio" name="p3preventative" value="grapple" checked> Grapple</label>
                    </div>
                </div>
            </div>

            <button class="start-btn" onclick="startGame()">Begin Adventure</button>
        </div>
    </div>

    <!-- ==================== MAIN GAME ==================== -->
    <div class="game-screen hidden" id="gameScreen">
        <div class="game-container">
            <div class="header">
                <h1>UNTITLED DICE GAME</h1>
                <div class="floor-info">
                    <span>Floor 1: The Dirty Innkeeper</span>
                    <span class="gold" id="goldDisplay">0G</span>
                    <div class="doom-hope-display">
                        <div class="doom-meter"><span id="doomDisplay">0</span> DOOM</div>
                        <div class="hope-meter"><span id="hopeDisplay">0</span> HOPE</div>
                    </div>
                </div>
                <div class="header-buttons">
                    <button class="header-btn" onclick="showPauseMenu()">Menu</button>
                </div>
            </div>

            <div class="main-area">
                <div class="players-panel">
                    <h3>Party</h3>
                    <div id="playersDisplay"></div>
                </div>

                <div class="encounter-panel">
                    <div class="encounter-content" id="encounterContent">
                        <div class="encounter-header">
                            <h2 id="encounterTitle">The Rusty Tankard</h2>
                            <span class="encounter-type" id="encounterType" style="display:none;"></span>
                        </div>
                        <div class="encounter-description" id="encounterDescription">
                            <p>Your party arrives at The Rusty Tankard inn as dusk settles over the town. Rumors of the innkeeper's shady dealings have reached your ears...</p>
                            <p style="margin-top:15px;">Click the <strong>house icon</strong> on the map to enter and begin your adventure.</p>
                        </div>
                        <div class="encounter-options" id="encounterOptions"></div>
                    </div>
                </div>

                <div class="map-panel">
                    <h2>Map</h2>
                    <div class="map-container" id="mapContainer"></div>
                </div>
            </div>

            <div class="dice-tray">
                <div class="dice-tray-header">Dice Tray - Click to Roll</div>
                <div class="dice-grid" id="diceTray"></div>
            </div>
        </div>

        <div class="game-log" id="gameLog">
            <h4>Log</h4>
        </div>
    </div>

    <!-- ==================== MODALS ==================== -->

    <!-- Roll Result -->
    <div class="modal roll-result" id="rollResult">
        <div class="roll-result-content">
            <h2 id="rollDieName">Rolling...</h2>
            <div id="swapTriggered" class="swap-triggered" style="display:none;"></div>
            <div class="result-value" id="rollValue">?</div>
            <div id="doomChange" class="doom-change" style="display:none;"></div>
            <div class="outcome" id="rollOutcome"></div>
            <button onclick="closeRollResult()">Continue</button>
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div class="modal upgrade-modal" id="upgradeModal">
        <div class="modal-content">
            <h2 id="upgradeTitle">Choose an Upgrade</h2>
            <p id="upgradeDescription"></p>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>

    <!-- Pause Modal -->
    <div class="modal pause-modal" id="pauseModal">
        <div class="modal-content">
            <h2>Paused</h2>
            <div class="pause-menu">
                <button class="menu-btn" onclick="closePauseMenu()">Resume</button>
                <button class="menu-btn" onclick="restartGame()">Restart Floor</button>
                <button class="menu-btn" onclick="quitToMenu()">Quit to Menu</button>
            </div>
        </div>
    </div>

    <!-- Victory Screen -->
    <div class="screen end-screen victory hidden" id="victoryScreen">
        <div class="end-content">
            <h1>VICTORY!</h1>
            <p>You have defeated the Dirty Innkeeper!</p>
            <p style="color:#ffd700;">Floor 2 awaits your party...</p>
            <div class="end-buttons">
                <button class="menu-btn primary" onclick="location.reload()">Play Again</button>
                <button class="menu-btn" onclick="quitToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Defeat Screen -->
    <div class="screen end-screen defeat hidden" id="defeatScreen">
        <div class="end-content">
            <h1>DEFEAT</h1>
            <p id="defeatReason">Your party has fallen...</p>
            <div class="end-buttons">
                <button class="menu-btn primary" onclick="location.reload()">Try Again</button>
                <button class="menu-btn" onclick="quitToMenu()">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME STATE ====================
        const gameState = {
            gold: 0,
            doom: 0,
            hope: 0,
            currentNode: 0,
            players: [],
            map: [],
            currentEncounter: null,
            encounterState: null,
            targetDC: 10,
            canRoll: false,
            allowedDiceTypes: ['physical', 'verbal', 'preventative'],
            pendingSwapResult: null,
            // Voting system
            voting: {
                active: false,
                options: [],
                votes: {}, // playerIdx -> optionIdx
                round: 1,
                node: null
            }
        };

        // ==================== DEFINITIONS ====================
        const DICE_TYPES = {
            slash: { name: 'Slash', category: 'physical', icon: 'SL' },
            stab: { name: 'Stab', category: 'physical', icon: 'ST' },
            bonk: { name: 'Bonk', category: 'physical', icon: 'BK' },
            threaten: { name: 'Threaten', category: 'verbal', icon: 'TH' },
            deceive: { name: 'Deceive', category: 'verbal', icon: 'DC' },
            persuade: { name: 'Persuade', category: 'verbal', icon: 'PR' },
            bribe: { name: 'Bribe', category: 'preventative', icon: 'BR' },
            hide: { name: 'Hide', category: 'preventative', icon: 'HD' },
            grapple: { name: 'Grapple', category: 'preventative', icon: 'GR' }
        };

        const ENCOUNTERS = {
            start: {
                type: 'start',
                name: 'The Rusty Tankard',
                description: 'You push open the creaky door and enter the dingy inn. The air smells of stale ale and something worse. Shadowy figures huddle in corners, and the innkeeper watches you with suspicious eyes.',
                icon: 'ðŸ ',
                options: [
                    { text: 'Look around and proceed', action: 'leave' }
                ]
            },
            mathematician: {
                type: 'good',
                name: 'The Mathematician',
                description: 'A strange old man with ink-stained fingers beckons you. "Numbers are my trade. For a small fee, I can... adjust your dice."',
                icon: 'ðŸ”¢',
                options: [
                    { text: '10G: +2 to lowest face', cost: 10, action: 'upgrade_plus2' },
                    { text: '25G: +5 to lowest face', cost: 25, action: 'upgrade_plus5' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            alchemist: {
                type: 'good',
                name: 'The Alchemist',
                description: 'Bubbling potions fill the cramped shop. A wild-eyed woman grins at you. "I can splice your dice together! Link your fates... for science!"',
                icon: 'âš—ï¸',
                options: [
                    { text: '15G: Link a low roll to ally\'s die', cost: 15, action: 'swap_low_to_ally' },
                    { text: '30G: Link a high roll to ally\'s die', cost: 30, action: 'swap_high_to_ally' },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            priest: {
                type: 'good',
                name: 'The Priest',
                description: 'A serene figure in white robes offers a blessing. "Let me infuse your dice with HOPE. The light will protect you in dark times."',
                icon: 'âœ¨',
                options: [
                    { text: 'Accept Blessing (+3 HOPE)', action: 'blessing_hope' },
                    { text: 'Refuse politely', action: 'leave' }
                ]
            },
            gambler: {
                type: 'good',
                name: 'The Gambler',
                description: 'A shifty-eyed woman shuffles cards. "Care for a wager? Roll above 15 and I\'ll double your gold. Fail, and... well."',
                icon: 'ðŸŽ°',
                options: [
                    { text: 'Gamble 20G', cost: 20, action: 'gamble', dc: 15 },
                    { text: 'Leave', action: 'leave' }
                ]
            },
            bandits: {
                type: 'bad',
                name: 'Bandit Ambush!',
                description: 'Three rough-looking thugs block your path! "Your gold or your lives!"',
                icon: 'âš”ï¸',
                dc: 12, hp: 30, reward: 30,
                options: [
                    { text: 'Fight! (Physical)', types: ['physical'], action: 'combat' },
                    { text: 'Intimidate (Verbal)', types: ['verbal'], action: 'combat' },
                    { text: 'Slip away (Preventative)', types: ['preventative'], action: 'combat' }
                ]
            },
            guards: {
                type: 'bad',
                name: 'Corrupt Guards',
                description: 'Two city guards eye you suspiciously. "Pay the \'peace tax\' or face justice."',
                icon: 'ðŸ›¡ï¸',
                dc: 13, hp: 25, reward: 25,
                options: [
                    { text: 'Resist! (Physical)', types: ['physical'], action: 'combat' },
                    { text: 'Talk out (Verbal)', types: ['verbal'], action: 'combat' },
                    { text: 'Bribe/Hide (Preventative)', types: ['preventative'], action: 'combat' }
                ]
            },
            ferryman: {
                type: 'neutral',
                name: 'The Ferryman',
                description: 'An ancient boatman waits by dark waters. "I\'ll take you across... but each of you must offer a die for me to mark. One face will be crossed out - and when you roll it, something... unfortunate happens." He gestures to the cold river. "Or you could swim, I suppose."',
                icon: 'â›µ',
                vote: true,
                options: [
                    { text: 'Pay the Ferryman (Each die gets a crossed face)', action: 'ferryman_mark' },
                    { text: 'Swim across (+3 DOOM, wet and miserable)', action: 'ferryman_swim' }
                ]
            },
            trapper: {
                type: 'neutral',
                name: 'The Trapper',
                description: 'A grizzled hunter displays strange dice covered in scratch marks and odd symbols. "Found these in the dungeon. Trade you straight up - your worst for my random."',
                icon: 'ðŸª¤',
                vote: true,
                options: [
                    { text: 'Trade: Swap lowest for random', action: 'trapper_trade' },
                    { text: 'Leave empty-handed', action: 'leave' }
                ]
            },
            drunkPriest: {
                type: 'neutral',
                name: 'The Drunk Priest',
                description: 'A priest stumbles towards you, bottle in hand. "Blessings! I can give you HOPE! ...hic... but my aim isn\'t what it used to be. Might add some DOOM too..."',
                icon: 'ðŸº',
                vote: true,
                options: [
                    { text: 'Accept Sloppy Blessing', action: 'drunk_blessing' },
                    { text: 'Decline politely', action: 'leave' }
                ]
            },
            cultist: {
                type: 'neutral',
                name: 'The Cultist',
                description: 'A robed figure offers you a goblet of strange purple liquid. "Join us, just for a moment. Drink, and your fate becomes intertwined with your companions. Refuse, and... DOOM approaches."',
                icon: 'ðŸ·',
                vote: true,
                options: [
                    { text: 'Drink (Random Swap + Bonus)', action: 'cultist_drink' },
                    { text: 'Refuse (+2 DOOM)', action: 'cultist_refuse' }
                ]
            },
            miniboss: {
                type: 'bad',
                name: 'The Innkeeper\'s Thug',
                description: 'A massive bouncer blocks the stairs. "Boss don\'t want visitors." His fists look like hammers.',
                icon: 'ðŸ’ª',
                dc: 14, hp: 40, reward: 40,
                options: [
                    { text: 'Overpower (Physical)', types: ['physical'], action: 'combat' },
                    { text: 'Convince (Verbal)', types: ['verbal'], action: 'combat' },
                    { text: 'Distract (Preventative)', types: ['preventative'], action: 'combat' }
                ]
            },
            boss: {
                type: 'boss',
                name: 'The Dirty Innkeeper',
                description: 'The innkeeper reveals his true nature - a cunning crime lord! "You\'ve meddled enough. Time to deal with you personally."',
                icon: 'ðŸ‘‘',
                dc: 15, hp: 60, reward: 100,
                options: [
                    { text: 'Attack! (Physical)', types: ['physical'], action: 'combat' },
                    { text: 'Expose crimes (Verbal)', types: ['verbal'], action: 'combat' },
                    { text: 'Defend (Preventative)', types: ['preventative'], action: 'combat' }
                ]
            }
        };

        // ==================== SCREEN MANAGEMENT ====================
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
        }

        function showPauseMenu() {
            document.getElementById('pauseModal').classList.add('show');
        }

        function closePauseMenu() {
            document.getElementById('pauseModal').classList.remove('show');
        }

        function restartGame() {
            location.reload();
        }

        function quitToMenu() {
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('show'));
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('titleScreen').classList.remove('hidden');
        }

        // ==================== GAME INITIALIZATION ====================
        function startGame() {
            gameState.players = [];
            gameState.gold = 0;
            gameState.doom = 0;
            gameState.hope = 0;
            gameState.map = [];

            for (let p = 1; p <= 3; p++) {
                const name = document.getElementById(`p${p}name`).value || `Player ${p}`;
                const physical = document.querySelector(`input[name="p${p}physical"]:checked`).value;
                const verbal = document.querySelector(`input[name="p${p}verbal"]:checked`).value;
                const preventative = document.querySelector(`input[name="p${p}preventative"]:checked`).value;

                gameState.players.push({
                    id: p,
                    name: name,
                    hp: 20,
                    maxHp: 20,
                    dice: {
                        physical: createDie(physical),
                        verbal: createDie(verbal),
                        preventative: createDie(preventative)
                    }
                });
            }

            generateMap();

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');

            renderMap();
            renderPlayers();
            renderDiceTray();
            updateDoomHopeDisplay();

            gameState.map[0].status = 'available';
            renderMap();

            document.getElementById('gameLog').innerHTML = '<h4>Log</h4>';
            log('Click the inn to begin...', 'info');
        }

        function createDie(type) {
            return {
                type: type,
                ...DICE_TYPES[type],
                faces: Array.from({length: 20}, (_, i) => i + 1),
                swaps: [], // Array of {faceValue, targetPlayer, targetDieType}
                hopeSegments: [], // Face values that grant HOPE when rolled
                crossedSegments: [], // Face values marked by Ferryman (one-time, triggers penalty)
                lastRoll: null
            };
        }

        function generateMap() {
            const structure = [
                { encounter: 'start', row: 0 },
                { encounter: 'mathematician', row: 1 },
                { encounter: 'bandits', row: 1 },
                { encounter: 'alchemist', row: 2 },
                { encounter: 'ferryman', row: 2 },
                { encounter: 'priest', row: 2 },
                { encounter: 'guards', row: 3 },
                { encounter: 'trapper', row: 3 },
                { encounter: 'gambler', row: 4 },
                { encounter: 'drunkPriest', row: 4 },
                { encounter: 'cultist', row: 4 },
                { encounter: 'miniboss', row: 5 },
                { encounter: 'boss', row: 6 }
            ];

            gameState.map = structure.map((node, index) => ({
                id: index,
                ...ENCOUNTERS[node.encounter],
                encounterKey: node.encounter,
                row: node.row,
                status: index === 0 ? 'current' : 'locked',
                connections: []
            }));

            // Build connections
            gameState.map[0].connections = [1, 2];
            gameState.map[1].connections = [3, 4, 5];
            gameState.map[2].connections = [3, 4, 5];
            gameState.map[3].connections = [6, 7];
            gameState.map[4].connections = [6, 7];
            gameState.map[5].connections = [6, 7];
            gameState.map[6].connections = [8, 9, 10];
            gameState.map[7].connections = [8, 9, 10];
            gameState.map[8].connections = [11];
            gameState.map[9].connections = [11];
            gameState.map[10].connections = [11];
            gameState.map[11].connections = [12];
        }

        // ==================== RENDERING ====================
        function renderMap() {
            const container = document.getElementById('mapContainer');
            container.innerHTML = '';

            const rows = {};
            gameState.map.forEach(node => {
                if (!rows[node.row]) rows[node.row] = [];
                rows[node.row].push(node);
            });

            const rowKeys = Object.keys(rows).sort((a, b) => b - a);

            rowKeys.forEach((rowKey, rowIndex) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'map-row';

                rows[rowKey].forEach(node => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `map-node ${node.type} ${node.status}`;
                    nodeDiv.innerHTML = node.icon;
                    nodeDiv.title = node.name;

                    if (node.status === 'available') {
                        nodeDiv.onclick = () => selectNode(node.id);
                    }

                    rowDiv.appendChild(nodeDiv);
                });

                container.appendChild(rowDiv);

                if (rowIndex < rowKeys.length - 1) {
                    const pathDiv = document.createElement('div');
                    pathDiv.className = 'map-path';
                    container.appendChild(pathDiv);
                }
            });
        }

        function renderPlayers() {
            const container = document.getElementById('playersDisplay');
            container.innerHTML = '';

            gameState.players.forEach((player, idx) => {
                const card = document.createElement('div');
                card.className = `player-card player-${player.id}`;

                const hpPercent = (player.hp / player.maxHp) * 100;
                const hpColor = hpPercent > 50 ? '#4ade80' : hpPercent > 25 ? '#ffd700' : '#f87171';

                card.innerHTML = `
                    <h3>${player.name} <span class="player-hp" style="color:${hpColor}">${player.hp}HP</span></h3>
                    <div class="player-dice-mini">
                        ${Object.entries(player.dice).map(([type, die]) => {
                            const hasSwaps = die.swaps && die.swaps.length > 0;
                            const hasCrossed = die.crossedSegments && die.crossedSegments.length > 0;
                            return `
                                <div class="mini-die ${die.category}" title="${die.name}${hasSwaps ? ' (linked)' : ''}${hasCrossed ? ' (marked)' : ''}">
                                    ${die.icon}
                                    ${hasSwaps ? '<span class="swap-indicator">âŸ·</span>' : ''}
                                    ${hasCrossed ? '<span class="swap-indicator" style="background:#8b0000;">â¨‚</span>' : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function renderDiceTray() {
            const tray = document.getElementById('diceTray');
            tray.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                const group = document.createElement('div');
                group.className = `player-dice-group player-${player.id}`;
                group.innerHTML = `<h4>${player.name}</h4>`;

                const row = document.createElement('div');
                row.className = 'dice-row';

                Object.entries(player.dice).forEach(([type, die]) => {
                    const dieEl = document.createElement('div');
                    const hasSwaps = die.swaps && die.swaps.length > 0;
                    const hasCrossed = die.crossedSegments && die.crossedSegments.length > 0;
                    dieEl.className = `die ${die.category} player-${player.id}${hasSwaps ? ' has-swap' : ''}`;
                    dieEl.dataset.player = pIdx;
                    dieEl.dataset.type = type;

                    const canUse = gameState.canRoll &&
                                   gameState.allowedDiceTypes.includes(die.category) &&
                                   player.hp > 0;

                    if (!canUse) {
                        dieEl.classList.add('disabled');
                    } else {
                        dieEl.onclick = () => rollDie(pIdx, type);
                    }

                    dieEl.innerHTML = `
                        <span class="die-name">${die.name}</span>
                        <span class="die-value">${die.lastRoll || 'd20'}</span>
                        ${hasSwaps ? `<span class="swap-badge">${die.swaps.length}</span>` : ''}
                        ${hasCrossed ? `<span class="swap-badge" style="background:#8b0000;left:-8px;right:auto;">â¨‚</span>` : ''}
                    `;

                    row.appendChild(dieEl);
                });

                group.appendChild(row);
                tray.appendChild(group);
            });
        }

        function updateDoomHopeDisplay() {
            document.getElementById('doomDisplay').textContent = gameState.doom;
            document.getElementById('hopeDisplay').textContent = gameState.hope;
            document.getElementById('goldDisplay').textContent = `${gameState.gold}G`;
        }

        // ==================== DOOM/HOPE SYSTEM ====================
        function addDoom(amount, reason = '') {
            gameState.doom += amount;
            updateDoomHopeDisplay();
            if (reason) {
                log(`+${amount} DOOM: ${reason}`, 'doom');
            }
        }

        function reduceDoom(amount) {
            const reduced = Math.min(gameState.doom, amount);
            gameState.doom -= reduced;
            updateDoomHopeDisplay();
            return reduced;
        }

        function addHope(amount) {
            if (gameState.doom > 0) {
                const reduced = Math.min(gameState.doom, amount);
                gameState.doom -= reduced;
                log(`HOPE offset ${reduced} DOOM!`, 'hope');
                updateDoomHopeDisplay();
            } else {
                log(`HOPE wasted (no DOOM to offset)`, 'info');
            }
        }

        function getEffectiveRoll(baseRoll) {
            // DOOM reduces all non-20 rolls
            if (baseRoll === 20) return 20;
            const effective = Math.max(1, baseRoll - gameState.doom);
            return effective;
        }

        // ==================== ENCOUNTERS ====================
        function selectNode(nodeId) {
            const node = gameState.map[nodeId];
            if (node.status !== 'available') return;

            const currentNode = gameState.map.find(n => n.status === 'current');
            if (currentNode) currentNode.status = 'completed';

            node.status = 'current';
            gameState.currentNode = nodeId;
            gameState.currentEncounter = node;

            node.connections.forEach(connId => {
                if (gameState.map[connId].status === 'locked') {
                    gameState.map[connId].status = 'available';
                }
            });

            renderMap();
            showEncounter(node);
            log(`Entered: ${node.name}`, 'info');
        }

        function showEncounter(node) {
            document.getElementById('encounterTitle').textContent = node.name;
            document.getElementById('encounterDescription').innerHTML = `<p>${node.description}</p>`;

            const typeSpan = document.getElementById('encounterType');
            typeSpan.style.display = 'inline-block';
            typeSpan.className = `encounter-type ${node.type}`;
            typeSpan.textContent = node.type.toUpperCase();

            const optionsDiv = document.getElementById('encounterOptions');
            optionsDiv.innerHTML = '';

            // Check if this is a voting encounter
            if (node.vote && node.options) {
                startVoting(node);
                return;
            }

            if (node.options) {
                node.options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    if (opt.types) btn.classList.add(opt.types[0]);
                    if (opt.action.includes('swap')) btn.classList.add('swap');
                    btn.textContent = opt.text;

                    if (opt.cost && gameState.gold < opt.cost) {
                        btn.disabled = true;
                        btn.title = 'Not enough gold';
                    }

                    btn.onclick = () => handleOption(opt, node);
                    optionsDiv.appendChild(btn);
                });
            }

            gameState.encounterState = { enemyHp: node.hp || 0 };
            gameState.canRoll = false;
            gameState.allowedDiceTypes = ['physical', 'verbal', 'preventative'];
            renderDiceTray();
        }

        // ==================== VOTING SYSTEM ====================
        function startVoting(node) {
            gameState.voting = {
                active: true,
                options: node.options,
                votes: {},
                round: 1,
                node: node
            };
            renderVotingUI();
        }

        function renderVotingUI() {
            const optionsDiv = document.getElementById('encounterOptions');
            const v = gameState.voting;

            let voteStatus = `<div style="margin-bottom:15px; padding:10px; background:rgba(255,215,0,0.1); border-radius:8px; border:1px solid #ffd700;">
                <strong style="color:#ffd700;">VOTE (Round ${v.round}/2)</strong><br>
                <span style="color:#aaa;">Each player picks an option. Majority wins!</span>
            </div>`;

            // Show current votes
            gameState.players.forEach((player, pIdx) => {
                const voted = v.votes[pIdx] !== undefined;
                const votedFor = voted ? v.options[v.votes[pIdx]].text : 'Not voted';
                voteStatus += `<div style="margin:5px 0; color:${voted ? '#4ade80' : '#888'};">
                    ${player.name}: ${voted ? votedFor : '...'}</div>`;
            });

            optionsDiv.innerHTML = voteStatus;

            // Show voting buttons for each player
            gameState.players.forEach((player, pIdx) => {
                if (v.votes[pIdx] !== undefined) return; // Already voted

                const playerVoteDiv = document.createElement('div');
                playerVoteDiv.style.cssText = 'margin-top:15px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;';
                playerVoteDiv.innerHTML = `<strong style="color:#88ccff;">${player.name}'s Vote:</strong>`;

                const btnRow = document.createElement('div');
                btnRow.style.cssText = 'display:flex; gap:10px; margin-top:8px; flex-wrap:wrap;';

                v.options.forEach((opt, optIdx) => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.style.cssText = 'flex:1; min-width:120px;';
                    btn.textContent = opt.text;

                    if (opt.cost && gameState.gold < opt.cost) {
                        btn.disabled = true;
                        btn.title = 'Not enough gold';
                    }

                    btn.onclick = () => castVote(pIdx, optIdx);
                    btnRow.appendChild(btn);
                });

                playerVoteDiv.appendChild(btnRow);
                optionsDiv.appendChild(playerVoteDiv);
            });
        }

        function castVote(playerIdx, optionIdx) {
            gameState.voting.votes[playerIdx] = optionIdx;
            log(`${gameState.players[playerIdx].name} voted!`, 'info');

            // Check if all players have voted
            const voteCount = Object.keys(gameState.voting.votes).length;
            if (voteCount >= gameState.players.length) {
                resolveVote();
            } else {
                renderVotingUI();
            }
        }

        function resolveVote() {
            const v = gameState.voting;

            // Count votes
            const counts = {};
            Object.values(v.votes).forEach(optIdx => {
                counts[optIdx] = (counts[optIdx] || 0) + 1;
            });

            // Find winner(s)
            const maxVotes = Math.max(...Object.values(counts));
            const winners = Object.keys(counts).filter(k => counts[k] === maxVotes);

            if (winners.length === 1) {
                // Clear winner!
                const winningOption = v.options[parseInt(winners[0])];
                log(`Vote passed: "${winningOption.text}"`, 'success');
                gameState.voting.active = false;
                handleOption(winningOption, v.node);
            } else if (v.round === 1) {
                // Tie - vote again
                log('Tie! Vote again...', 'info');
                v.round = 2;
                v.votes = {};
                renderVotingUI();
            } else {
                // Second tie - random selection from tied options
                const randomWinner = winners[Math.floor(Math.random() * winners.length)];
                const winningOption = v.options[parseInt(randomWinner)];
                log(`Tie broken randomly: "${winningOption.text}"`, 'info');
                gameState.voting.active = false;
                handleOption(winningOption, v.node);
            }
        }

        function handleOption(option, node) {
            switch(option.action) {
                case 'leave':
                    completeEncounter();
                    break;
                case 'combat':
                    startCombat(option, node);
                    break;
                case 'upgrade_plus2':
                    if (spendGold(option.cost)) showUpgradeModal(2);
                    break;
                case 'upgrade_plus5':
                    if (spendGold(option.cost)) showUpgradeModal(5);
                    break;
                case 'swap_low_to_ally':
                    if (spendGold(option.cost)) showSwapModal('low');
                    break;
                case 'swap_high_to_ally':
                    if (spendGold(option.cost)) showSwapModal('high');
                    break;
                case 'blessing_hope':
                    addHope(3);
                    log('The priest\'s blessing fills you with HOPE!', 'hope');
                    completeEncounter();
                    break;
                case 'gamble':
                    if (spendGold(option.cost)) {
                        gameState.canRoll = true;
                        gameState.targetDC = option.dc;
                        gameState.encounterState = { type: 'gamble', wager: option.cost };
                        document.getElementById('encounterDescription').innerHTML +=
                            '<p style="color:#ffd700;margin-top:15px;">Roll any die! Beat 15 to double!</p>';
                        renderDiceTray();
                    }
                    break;
                case 'ferryman_mark':
                    handleFerrymanMark();
                    break;
                case 'ferryman_swim':
                    addDoom(3, 'Swam through cold, dark waters');
                    log('The party swims across, shivering and miserable...', 'fail');
                    completeEncounter();
                    break;
                case 'trapper_trade':
                    showTrapperTrade();
                    break;
                case 'drunk_blessing':
                    handleDrunkBlessing();
                    break;
                case 'cultist_drink':
                    handleCultistDrink();
                    break;
                case 'cultist_refuse':
                    addDoom(2, 'The cultist\'s curse follows you...');
                    completeEncounter();
                    break;
            }
        }

        function startCombat(option, node) {
            gameState.canRoll = true;
            gameState.targetDC = node.dc;
            gameState.allowedDiceTypes = option.types;
            gameState.encounterState = {
                type: 'combat',
                enemyHp: node.hp,
                enemyName: node.name,
                reward: node.reward,
                isBoss: node.type === 'boss'
            };

            document.getElementById('encounterDescription').innerHTML = `
                <p>${node.description}</p>
                <div style="margin-top:20px; padding:15px; background:rgba(255,50,50,0.15); border-radius:10px; border-left:4px solid #f87171;">
                    <h3 style="color:#f87171;">${node.name}</h3>
                    <p style="font-size:1.2rem;"><span id="enemyHp">${node.hp}</span> / ${node.hp} HP</p>
                    <p style="color:#aaa;">DC to hit: ${node.dc}</p>
                </div>
                <p style="margin-top:15px; color:#88ccff;">Roll <strong>${option.types.join(' or ')}</strong> dice!</p>
            `;

            document.getElementById('encounterOptions').innerHTML = '';
            renderDiceTray();
        }

        // ==================== DICE ROLLING ====================
        function rollDie(playerIndex, dieType) {
            if (!gameState.canRoll) return;

            const player = gameState.players[playerIndex];
            const die = player.dice[dieType];

            if (!gameState.allowedDiceTypes.includes(die.category)) {
                log(`Can't use ${die.name} here!`, 'fail');
                return;
            }

            const dieElement = document.querySelector(`[data-player="${playerIndex}"][data-type="${dieType}"]`);
            dieElement.classList.add('rolling');

            setTimeout(() => {
                dieElement.classList.remove('rolling');
                const faceIndex = Math.floor(Math.random() * 20);
                let result = die.faces[faceIndex];

                // Check for swaps
                const swap = die.swaps.find(s => s.faceValue === result);
                let swapInfo = null;

                if (swap) {
                    // Trigger the swapped die!
                    const targetPlayer = gameState.players[swap.targetPlayer];
                    const targetDie = targetPlayer.dice[swap.targetDieType];
                    const swapRoll = targetDie.faces[Math.floor(Math.random() * 20)];

                    swapInfo = {
                        originalRoll: result,
                        swappedTo: targetPlayer.name,
                        swappedDie: targetDie.name,
                        newRoll: swapRoll
                    };

                    result = swapRoll;
                    log(`SWAP! ${result} triggered ${targetPlayer.name}'s ${targetDie.name}!`, 'swap');
                }

                // Check for Ferryman's crossed segments (one-time penalty)
                let crossedTriggered = false;
                const crossedIdx = die.crossedSegments.indexOf(result);
                if (crossedIdx !== -1) {
                    crossedTriggered = true;
                    // Remove it (one-time only)
                    die.crossedSegments.splice(crossedIdx, 1);
                    log(`CROSSED! The Ferryman's mark activates on ${result}!`, 'doom');
                }

                die.lastRoll = result;
                showRollResult(player, die, result, swapInfo, crossedTriggered);
            }, 600);
        }

        function showRollResult(player, die, result, swapInfo = null, crossedTriggered = false) {
            const modal = document.getElementById('rollResult');
            const valueEl = document.getElementById('rollValue');
            const outcomeEl = document.getElementById('rollOutcome');
            const swapEl = document.getElementById('swapTriggered');
            const doomChangeEl = document.getElementById('doomChange');

            document.getElementById('rollDieName').textContent = `${player.name}'s ${die.name}`;

            // Show swap info if applicable
            if (swapInfo) {
                swapEl.style.display = 'block';
                swapEl.innerHTML = `Rolled ${swapInfo.originalRoll} â†’ Linked to ${swapInfo.swappedTo}'s ${swapInfo.swappedDie}!`;
            } else if (crossedTriggered) {
                swapEl.style.display = 'block';
                swapEl.innerHTML = `<span style="color:#ff6b6b;">â¨‚ FERRYMAN'S MARK! The crossed face triggered!</span>`;
            } else {
                swapEl.style.display = 'none';
            }

            // Apply DOOM effect
            const effectiveResult = getEffectiveRoll(result);
            const doomReduction = result - effectiveResult;

            valueEl.textContent = effectiveResult;
            if (doomReduction > 0) {
                doomChangeEl.style.display = 'block';
                doomChangeEl.className = 'doom-change doom-up';
                doomChangeEl.textContent = `DOOM reduced roll: ${result} â†’ ${effectiveResult}`;
            } else {
                doomChangeEl.style.display = 'none';
            }

            // Handle crossed segment penalty
            let crossedDoomPenalty = 0;
            if (crossedTriggered) {
                crossedDoomPenalty = 2;
                addDoom(crossedDoomPenalty, 'Ferryman\'s mark triggered');
            }

            valueEl.className = 'result-value';
            let doomDelta = 0;

            if (result === 20) {
                valueEl.classList.add('crit');
                outcomeEl.textContent = 'NATURAL 20!';
                // Nat 20 removes half DOOM
                if (gameState.doom > 0) {
                    const reduced = reduceDoom(Math.ceil(gameState.doom / 2));
                    doomChangeEl.style.display = 'block';
                    doomChangeEl.className = 'doom-change doom-down';
                    doomChangeEl.textContent = `Nat 20 removed ${reduced} DOOM!`;
                }
            } else if (effectiveResult === 1) {
                valueEl.classList.add('fail');
                outcomeEl.textContent = 'CRITICAL FAIL!';
                doomDelta = 2;
            } else if (effectiveResult >= gameState.targetDC) {
                valueEl.classList.add('success');
                outcomeEl.textContent = 'Success!';
            } else {
                valueEl.classList.add('fail');
                outcomeEl.textContent = 'Failed...';
                doomDelta = 1;
            }

            // Check for HOPE on this segment
            if (die.hopeSegments && die.hopeSegments.includes(result)) {
                addHope(1);
            }

            modal.classList.add('show');
            processRollResult(player, die, effectiveResult, result, doomDelta);
        }

        function processRollResult(player, die, effectiveResult, naturalResult, doomDelta) {
            const state = gameState.encounterState;

            if (state.type === 'combat') {
                if (effectiveResult >= gameState.targetDC || naturalResult === 20) {
                    let damage = effectiveResult;
                    if (naturalResult === 20) damage = 40;

                    state.enemyHp -= damage;
                    log(`${player.name}'s ${die.name} deals ${damage}!`, naturalResult === 20 ? 'crit' : 'success');

                    if (state.enemyHp <= 0) {
                        gameState.canRoll = false;
                        document.getElementById('rollOutcome').textContent += ' DEFEATED!';
                        addGold(state.reward);

                        if (state.isBoss) {
                            setTimeout(() => {
                                document.getElementById('victoryScreen').classList.remove('hidden');
                            }, 1500);
                        }
                    } else {
                        document.getElementById('enemyHp').textContent = state.enemyHp;
                    }
                } else {
                    // Miss - take damage and add DOOM
                    const damage = Math.floor(Math.random() * 5) + 3;
                    player.hp -= damage;
                    addDoom(doomDelta, 'Combat failure');
                    log(`Miss! ${state.enemyName} hits ${player.name} for ${damage}!`, 'fail');

                    // Check for DOOM death
                    if (effectiveResult === 1 && gameState.doom >= 10) {
                        gameState.canRoll = false;
                        document.getElementById('defeatReason').textContent = 'DOOM consumed your party... The prophecy failed.';
                        setTimeout(() => {
                            document.getElementById('defeatScreen').classList.remove('hidden');
                        }, 1500);
                        return;
                    }

                    if (player.hp <= 0) {
                        player.hp = 0;
                        log(`${player.name} has fallen!`, 'fail');
                    }

                    if (gameState.players.every(p => p.hp <= 0)) {
                        gameState.canRoll = false;
                        setTimeout(() => {
                            document.getElementById('defeatScreen').classList.remove('hidden');
                        }, 1500);
                    }

                    renderPlayers();
                }
            } else if (state.type === 'gamble') {
                if (effectiveResult >= gameState.targetDC) {
                    addGold(state.wager * 2);
                    log(`Won! +${state.wager * 2} gold!`, 'crit');
                } else {
                    log('Lost the gamble...', 'fail');
                    addDoom(1, 'Lost gamble');
                }
                gameState.canRoll = false;
                setTimeout(completeEncounter, 1500);
            } else if (state.type === 'ferryman') {
                let narrative = '';
                if (naturalResult >= 15) {
                    narrative = 'The Ferryman grins as luck favors him. Swift passage!';
                    addGold(10);
                } else if (naturalResult >= 10) {
                    narrative = 'The Ferryman nods. A fair crossing.';
                } else if (naturalResult >= 5) {
                    narrative = 'The Ferryman winces. The boat rocks dangerously...';
                    addDoom(1, 'Rough crossing');
                } else {
                    narrative = 'The Ferryman howls! He barely survives the crossing.';
                    addDoom(2, 'Terrible crossing');
                }

                // Create a temporary swap as payment
                createRandomSwap(player, die);
                log(narrative, naturalResult >= 10 ? 'success' : 'fail');
                document.getElementById('rollOutcome').textContent = narrative;
                gameState.canRoll = false;
                setTimeout(completeEncounter, 2000);
            }

            renderDiceTray();
        }

        function closeRollResult() {
            document.getElementById('rollResult').classList.remove('show');
        }

        function completeEncounter() {
            document.getElementById('encounterTitle').textContent = 'Choose your path';
            document.getElementById('encounterType').style.display = 'none';
            document.getElementById('encounterDescription').innerHTML = '<p>Select an available location on the map.</p>';
            document.getElementById('encounterOptions').innerHTML = '';
            gameState.canRoll = false;
            gameState.currentEncounter = null;
            renderDiceTray();
        }

        // ==================== DICE SWAPPING ====================
        function createRandomSwap(player, die) {
            // Pick a random low face (1-5) to swap
            const lowFaces = die.faces.filter(f => f <= 5);
            if (lowFaces.length === 0) return;

            const faceToSwap = lowFaces[Math.floor(Math.random() * lowFaces.length)];

            // Pick a random other player and die
            const otherPlayers = gameState.players.filter(p => p.id !== player.id);
            const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const targetDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];

            die.swaps.push({
                faceValue: faceToSwap,
                targetPlayer: gameState.players.indexOf(targetPlayer),
                targetDieType: targetDieType
            });

            log(`${die.name} now linked: ${faceToSwap} â†’ ${targetPlayer.name}'s ${targetPlayer.dice[targetDieType].name}`, 'swap');
            renderPlayers();
            renderDiceTray();
        }

        function showSwapModal(type) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');

            const isLow = type === 'low';
            document.getElementById('upgradeTitle').textContent = isLow ?
                'Link a Low Roll to Ally' : 'Link a High Roll to Ally';
            document.getElementById('upgradeDescription').textContent = isLow ?
                'Choose a die, then pick a low number (1-5) to link to a teammate\'s die:' :
                'Choose a die, then pick a high number (16-19) to link to a teammate\'s die:';

            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([dieType, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option swap-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Click to add a swap link</p>
                    `;
                    opt.onclick = () => showSwapTargetPicker(pIdx, dieType, isLow);
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showSwapTargetPicker(sourcePlayerIdx, sourceDieType, isLow) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');
            const sourcePlayer = gameState.players[sourcePlayerIdx];
            const sourceDie = sourcePlayer.dice[sourceDieType];

            const range = isLow ? [1,2,3,4,5] : [16,17,18,19];

            document.getElementById('upgradeTitle').textContent = 'Choose Face & Target';
            document.getElementById('upgradeDescription').textContent =
                `Select which face of ${sourcePlayer.name}'s ${sourceDie.name} to link:`;

            options.innerHTML = '';

            range.forEach(faceValue => {
                // For each possible target
                gameState.players.forEach((targetPlayer, tpIdx) => {
                    if (tpIdx === sourcePlayerIdx) return;

                    Object.entries(targetPlayer.dice).forEach(([targetDieType, targetDie]) => {
                        const opt = document.createElement('div');
                        opt.className = 'upgrade-option swap-option';
                        opt.innerHTML = `
                            <h4>Roll ${faceValue} â†’ ${targetPlayer.name}'s ${targetDie.name}</h4>
                            <p>When you roll ${faceValue}, ${targetPlayer.name}'s ${targetDie.name} activates instead</p>
                        `;
                        opt.onclick = () => {
                            sourceDie.swaps.push({
                                faceValue: faceValue,
                                targetPlayer: tpIdx,
                                targetDieType: targetDieType
                            });
                            log(`Linked! ${sourceDie.name} ${faceValue} â†’ ${targetPlayer.name}'s ${targetDie.name}`, 'swap');
                            modal.classList.remove('show');
                            renderPlayers();
                            renderDiceTray();
                            completeEncounter();
                        };
                        options.appendChild(opt);
                    });
                });
            });
        }

        // ==================== UPGRADES ====================
        function showUpgradeModal(amount) {
            const modal = document.getElementById('upgradeModal');
            const options = document.getElementById('upgradeOptions');

            document.getElementById('upgradeTitle').textContent = `Add +${amount} to a Die`;
            document.getElementById('upgradeDescription').textContent = 'Choose which die to upgrade:';

            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Lowest face: ${Math.min(...die.faces)}</p>
                    `;
                    opt.onclick = () => {
                        const minIdx = die.faces.indexOf(Math.min(...die.faces));
                        die.faces[minIdx] += amount;
                        log(`Upgraded ${player.name}'s ${die.name}!`, 'success');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        function showTrapperTrade() {
            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Trapper\'s Trade';
            document.getElementById('upgradeDescription').textContent = 'Swap lowest face for random (1-20):';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            gameState.players.forEach((player, pIdx) => {
                Object.entries(player.dice).forEach(([type, die]) => {
                    const minVal = Math.min(...die.faces);
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.innerHTML = `
                        <h4>${player.name}'s ${die.name}</h4>
                        <p>Trade away: ${minVal}</p>
                    `;
                    opt.onclick = () => {
                        const minIdx = die.faces.indexOf(minVal);
                        const newVal = Math.floor(Math.random() * 20) + 1;
                        die.faces[minIdx] = newVal;
                        log(`Traded! ${die.name}: ${minVal} â†’ ${newVal}`, newVal > minVal ? 'success' : 'fail');
                        modal.classList.remove('show');
                        renderDiceTray();
                        completeEncounter();
                    };
                    options.appendChild(opt);
                });
            });

            modal.classList.add('show');
        }

        // ==================== SPECIAL ENCOUNTERS ====================
        function handleFerrymanMark() {
            // Each player selects one die to be marked by the Ferryman
            // That die gets a "crossed" segment (weighted to higher numbers)
            // When rolled, it triggers once and causes a penalty

            const modal = document.getElementById('upgradeModal');
            document.getElementById('upgradeTitle').textContent = 'The Ferryman\'s Mark';
            document.getElementById('upgradeDescription').textContent =
                'Each hero must offer one die to be marked. The Ferryman will cross out a face (weighted toward higher numbers). If you roll that face, something bad happens - once.';

            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            // Track which players have chosen
            if (!gameState.ferrymanChoices) {
                gameState.ferrymanChoices = {};
            }

            // Show status
            const statusDiv = document.createElement('div');
            statusDiv.style.cssText = 'margin-bottom:15px; padding:10px; background:rgba(100,100,200,0.1); border-radius:8px;';
            statusDiv.innerHTML = gameState.players.map(p => {
                const chosen = gameState.ferrymanChoices[p.id];
                return `<div style="color:${chosen ? '#4ade80' : '#888'}">${p.name}: ${chosen ? chosen : '...'}</div>`;
            }).join('');
            options.appendChild(statusDiv);

            // Show options for players who haven't chosen yet
            gameState.players.forEach((player, pIdx) => {
                if (gameState.ferrymanChoices[player.id]) return;

                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'margin-top:10px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;';
                playerDiv.innerHTML = `<strong style="color:#88ccff;">${player.name}, choose a die:</strong>`;

                Object.entries(player.dice).forEach(([type, die]) => {
                    const opt = document.createElement('div');
                    opt.className = 'upgrade-option';
                    opt.style.cssText = 'margin-top:8px;';
                    opt.innerHTML = `<h4>${die.name}</h4><p>Offer to the Ferryman</p>`;
                    opt.onclick = () => {
                        // Mark this die with a crossed segment (weighted to high numbers)
                        // Weights: 11-14 = 1x chance, 15-17 = 2x, 18-19 = 3x
                        const weightedPool = [];
                        for (let i = 11; i <= 14; i++) weightedPool.push(i);
                        for (let i = 15; i <= 17; i++) { weightedPool.push(i); weightedPool.push(i); }
                        for (let i = 18; i <= 19; i++) { weightedPool.push(i); weightedPool.push(i); weightedPool.push(i); }

                        const crossedFace = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                        die.crossedSegments.push(crossedFace);

                        gameState.ferrymanChoices[player.id] = `${die.name} (${crossedFace} crossed)`;
                        log(`${player.name}'s ${die.name}: face ${crossedFace} marked!`, 'doom');

                        // Check if all players have chosen
                        if (Object.keys(gameState.ferrymanChoices).length >= gameState.players.length) {
                            modal.classList.remove('show');
                            delete gameState.ferrymanChoices;
                            log('The Ferryman grins. "Safe passage... for now."', 'info');
                            completeEncounter();
                        } else {
                            handleFerrymanMark(); // Re-render
                        }
                    };
                    playerDiv.appendChild(opt);
                });

                options.appendChild(playerDiv);
            });

            modal.classList.add('show');
        }

        function handleDrunkBlessing() {
            // Adds HOPE to random segments but also adds DOOM
            const hopeGain = Math.floor(Math.random() * 3) + 2; // 2-4 HOPE
            const doomGain = Math.floor(Math.random() * 2) + 1; // 1-2 DOOM

            addHope(hopeGain);
            addDoom(doomGain, 'Sloppy blessing side effect');

            // Also add HOPE segments to random dice
            const randomPlayer = gameState.players[Math.floor(Math.random() * gameState.players.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
            const die = randomPlayer.dice[randomDieType];

            const segmentToHope = Math.floor(Math.random() * 10) + 1; // 1-10
            die.hopeSegments.push(segmentToHope);

            log(`Blessing added! Rolling ${segmentToHope} on ${die.name} grants +1 HOPE`, 'hope');
            completeEncounter();
        }

        function handleCultistDrink() {
            // Random swap + bonus
            const randomPlayer = gameState.players[Math.floor(Math.random() * gameState.players.length)];
            const dieTypes = ['physical', 'verbal', 'preventative'];
            const randomDieType = dieTypes[Math.floor(Math.random() * dieTypes.length)];
            const die = randomPlayer.dice[randomDieType];

            createRandomSwap(randomPlayer, die);

            // Bonus: +3 to a random face
            const randomFaceIdx = Math.floor(Math.random() * 20);
            die.faces[randomFaceIdx] += 3;

            log(`The drink takes hold... ${die.name} face ${die.faces[randomFaceIdx] - 3} â†’ ${die.faces[randomFaceIdx]}`, 'crit');
            completeEncounter();
        }

        // ==================== UTILITIES ====================
        function addGold(amount) {
            gameState.gold += amount;
            updateDoomHopeDisplay();
            log(`+${amount} Gold!`, 'crit');
        }

        function spendGold(amount) {
            if (gameState.gold >= amount) {
                gameState.gold -= amount;
                updateDoomHopeDisplay();
                return true;
            }
            return false;
        }

        function log(message, type = '') {
            const logDiv = document.getElementById('gameLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.getElementById('pauseModal').classList.contains('show')) {
                    closePauseMenu();
                } else if (document.getElementById('upgradeModal').classList.contains('show')) {
                    document.getElementById('upgradeModal').classList.remove('show');
                } else if (!document.getElementById('gameScreen').classList.contains('hidden')) {
                    showPauseMenu();
                }
            }
        });
    </script>
</body>
</html>
